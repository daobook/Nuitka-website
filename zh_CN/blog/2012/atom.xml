<?xml version='1.0' encoding='UTF-8'?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="zh_CN">
  <id>https://nuitka.net</id>
  <title>Nuitka Blog - Posted in 2012</title>
  <updated>2022-01-09T15:51:17.530406+00:00</updated>
  <link href="https://nuitka.net"/>
  <link href="https://nuitka.net/blog/2012/atom.xml" rel="self"/>
  <generator uri="https://ablog.readthedocs.org/" version="0.10.23">ABlog</generator>
  <entry>
    <id>https://nuitka.net/posts/nuitka-release-0317.html</id>
    <title>Nuitka Release 0.3.17</title>
    <updated>2012-01-09T07:59:00+00:00</updated>
    <author>
      <name>Kay Hayen</name>
    </author>
    <content type="html">&lt;section id="nuitka-release-0-3-17"&gt;

&lt;p&gt;This is to inform you about the new stable release of &lt;a class="reference external" href="https://nuitka.net"&gt;Nuitka&lt;/a&gt;. It is the extremely compatible Python compiler,
&lt;a class="reference external" href="/doc/download.html"&gt;“download now”&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;This is to inform you about the new stable release of Nuitka. This time
there are a few bug fixes, lots of very important organisational work,
and yet again improved compatibility and cleanups. Also huge is the
advance in making &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;--deep&lt;/span&gt;&lt;/code&gt; go away and making the recursion of Nuitka
controllable, which means a lot for scalability of projects that use a
lot of packages that use other packages, because now you can choose
which ones to embed and which ones one.&lt;/p&gt;
&lt;p&gt;The release cycle had a focus on improving the quality of the test
scripts, the packaging, and generally to prepare the work on “type
inference” in a new feature branch.&lt;/p&gt;
&lt;p&gt;I have also continued to work towards CPython3.2 compatibility, and this
version, while not there, supports Python3 with a large subset of the
basic tests programs running fine (of course via &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;2to3&lt;/span&gt;&lt;/code&gt; conversion)
without trouble. There is still work to do, exceptions don’t seem to
work fully yet, parameter parsing seems to have changed, etc. but it
seems that CPython3.2 is going to work one day.&lt;/p&gt;
&lt;p&gt;And there has been a lot of effort, to address the Debian packaging to
be cleaner and more complete, addressing issues that prevented it from
entering the Debian repository.&lt;/p&gt;
&lt;section id="bug-fixes"&gt;
&lt;h2&gt;Bug fixes&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;Fixed the handling of modules and packages of the same name, but with
different casing. Problem showed under Windows only. Released as
0.3.16a hot fix already.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Fixed an error where the command line length of Windows was exceeded
when many modules were embedded, Christopher Tott provided a fix for
it. Released as 0.3.16a hot fix already.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Fix, avoid to introduce new variables for where built-in exception
references are sufficient. Released as 0.3.16b hot fix already.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Fix, add the missing &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;staticmethod&lt;/span&gt;&lt;/code&gt; decorator to &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;__new__&lt;/span&gt;&lt;/code&gt;
methods before resolving the scopes of variables, this avoids the use
of that variable before it was assigned a scope. Released as 0.3.16b
hot fix already.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section id="new-features"&gt;
&lt;h2&gt;New Features&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Enhanced compatibility again, provide enough &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;co_varnames&lt;/span&gt;&lt;/code&gt; in the
code objects, so that slicing them up to &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;code_object.co_argcount&lt;/span&gt;&lt;/code&gt;
will work. They are needed by &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;inspect&lt;/span&gt;&lt;/code&gt; module and might be used by
some decorators as well.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;New options to control the recursion:&lt;/p&gt;
&lt;p&gt;&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;--recurse-none&lt;/span&gt;&lt;/code&gt; (do not warn about not-done recursions)
&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;--recurse-all&lt;/span&gt;&lt;/code&gt; (recurse to all otherwise warned modules)
&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;--recurse-to&lt;/span&gt;&lt;/code&gt; (confirm to recurse to those modules)
&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;--recurse-not-to&lt;/span&gt;&lt;/code&gt; (confirm to not recurse to those modules)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section id="optimization"&gt;
&lt;h2&gt;Optimization&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;The optimization of constant conditional expressions was not done
yet. Added this missing constant propagation case.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Eliminate near empty statement sequences (only contain a pass
statement) in more places, giving a cleaner node structure for many
constructs.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Use the pickle “protocol 2” on CPython2 except for &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;unicode&lt;/span&gt;&lt;/code&gt;
strings where it does not work well. It gives a more compressed and
binary representation, that is generally more efficient to un-stream
as well. Also use the cPickle protocol, the use of &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;pickle&lt;/span&gt;&lt;/code&gt; was not
really necessary anymore.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section id="organisational"&gt;
&lt;h2&gt;Organisational&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;Added a &lt;a class="reference external" href="https://nuitka.net/doc/developer-manual.html"&gt;Developer Manual&lt;/a&gt; to the release.
It’s incomplete, but it details some of the existing stuff, coding
rules, plans for “type inference”, etc.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Improved the &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;--help&lt;/span&gt;&lt;/code&gt; output to use &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;metavar&lt;/span&gt;&lt;/code&gt; where applicable.
This makes it more readable for some options.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Instead of error message, give help output when no module or program
file name was given. This makes Nuitka help out more convenient.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Consistently use &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;#!/usr/bin/env&lt;/span&gt; &lt;span class="pre"&gt;python&lt;/span&gt;&lt;/code&gt; for all scripts, this was
previously only done for some of them.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Ported the PyLint check script to Python as well, enhancing it on the
way to check the exit code, and to only output changes things, as
well as making the output of warnings for &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;TODO&lt;/span&gt;&lt;/code&gt; items optional.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;All scripts used for testing, PyLint checking, etc. now work with
Python3 as well. Most useful on Arch Linux, where it’s also already
the default for &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;Python&lt;/span&gt;&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The help output of Nuitka was polished a lot more. It is now more
readable and uses option groups to combine related options together.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Make the tests run without any dependence on &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;PATH&lt;/span&gt;&lt;/code&gt; to contain the
executables of Nuitka. This makes it easier to use.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Add license texts to 3rd party file that were missing them, apply
&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;licensecheck&lt;/span&gt;&lt;/code&gt; results to cleanup Nuitka. Also removed own
copyright statement from in-line copy of Scons, it had been added by
accident only.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Release the tests that I own as well as the Debian packaging I
created under “Apache License 2.0” which is very liberal, meaning
every project will be able to use it.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Don’t require copyright assignment for contributions anymore, instead
only “Apache License 2.0”, the future Nuitka license, so that the
code won’t be a problem when changing the license of all of Nuitka to
that license.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Give contributors listed in the &lt;a class="reference external" href="https://nuitka.net/doc/user-manual.html"&gt;User Manual&lt;/a&gt; an exception to the GPL
terms until Nuitka is licensed under “Apache License 2.0” as well.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Added an &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;--experimental&lt;/span&gt;&lt;/code&gt; option which can be used to control
experimental features, like the one currently being added on branch
&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;feature/ctypes_annotation&lt;/span&gt;&lt;/code&gt;, where “type inference” is currently
only activated when that option is given. For this stable release, it
does nothing.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Check the static C++ files of Nuitka with &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;cppcheck&lt;/span&gt;&lt;/code&gt; as well.
Didn’t find anything.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Arch Linux packages have been contributed, these are linked for
download, but the stable package may lag behind a bit.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section id="cleanups"&gt;
&lt;h2&gt;Cleanups&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;Changed &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;not&lt;/span&gt;&lt;/code&gt; boolean operation to become a normal operator.
Changed &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;and&lt;/span&gt;&lt;/code&gt; and &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;or&lt;/span&gt;&lt;/code&gt; boolean operators to a new base class, and
making their interface more similar to that of operations.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Added cumulative &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;tags&lt;/span&gt;&lt;/code&gt; to node classes for use in checks. Use it
annotate which node kinds to visit in e.g. per scope finalization
steps. That avoids kinds and class checks.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Enhanced the “visitor” interface to provide more kinds of callbacks,
enhanced the way “each scope” visiting is achieved by generalizing is
as “child has not tag ‘closure_taker’” and that for every “node that
has tag ‘closure_taker’”.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Moved &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;SyntaxHighlighting&lt;/span&gt;&lt;/code&gt; module to &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;nuitka.gui&lt;/span&gt;&lt;/code&gt; package where
it belongs.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;More white listing work for imports. As recursion is now the default,
and leads to warnings for non-existent modules, the CPython tests
gave a lot of good candidates for import errors that were white
listed.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Consistently use &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;nuitka&lt;/span&gt;&lt;/code&gt; in test scripts, as there isn’t a
&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;Nuitka.py&lt;/span&gt;&lt;/code&gt; on all platforms. The later is scheduled for removal.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Some more PyLint cleanups.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section id="new-tests"&gt;
&lt;h2&gt;New Tests&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Make sure the basic tests pass with CPython or else fail the test.
This is to prevent false positives, where a test passes, but only
because it fails in CPython early on and then does so with Nuitka
too. For the syntax tests we make sure they fail.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The basic tests can now be run with &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;PYTHON=python3.2&lt;/span&gt;&lt;/code&gt; and use
&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;2to3&lt;/span&gt;&lt;/code&gt; conversion in that case. Also the currently not passing
tests are not run, so the passing tests continue to do so, with this
run from the release test script &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;check-release&lt;/span&gt;&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Include the syntax tests in release tests as well.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Changed many existing tests so that they can run under CPython3 too.
Of course this is via &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;2to3&lt;/span&gt;&lt;/code&gt; conversion.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Don’t fail if the CPython test suites are not there.&lt;/p&gt;
&lt;p&gt;Currently they remain largely unpublished, and as such are mostly
only available to me (exception,
&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;feature/minimize_CPython26_tests_diff&lt;/span&gt;&lt;/code&gt; branch references the
CPython2.6 tests repository, but that remains work in progress).&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;For the compile itself test: Make the presence of the Scons in-line
copy optional, the Debian package doesn’t contain it.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Also make it more portable, so it runs under Windows too, and allow
to choose the Python version to test. Check this test with both
CPython2.6 and CPython2.7 not only the default Python.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Before releasing, test that the created Debian package builds fine in
a minimal Debian &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;unstable&lt;/span&gt;&lt;/code&gt; chroot, and passes all the tests
included in the package (&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;basics&lt;/span&gt;&lt;/code&gt;, &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;syntax&lt;/span&gt;&lt;/code&gt;, &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;programs&lt;/span&gt;&lt;/code&gt;,
&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;reflected&lt;/span&gt;&lt;/code&gt;). Also many other Debian packaging improvements.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section id="summary"&gt;
&lt;h2&gt;Summary&lt;/h2&gt;
&lt;p&gt;The “git flow” was used again in this release cycle and proved to be
useful not only for hot fix, but also for creating the branch
&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;feature/ctypes_annotation&lt;/span&gt;&lt;/code&gt; and rebasing it often while things are
still flowing.&lt;/p&gt;
&lt;p&gt;The few hot fixes didn’t require a new release, but the many
organisational improvements and the new features did warrant the new
release, because of e.g. the much better test handling in this release
and the improved recursion control.&lt;/p&gt;
&lt;p&gt;The work on Python3 support has slowed down a bit. I mostly only added
some bits for compatibility, but generally it has slowed down. I wanted
to make sure it doesn’t regress by accident, so running with CPython3.2
is now part of the normal release tests.&lt;/p&gt;
&lt;p&gt;What’s still missing is more “hg” completeness. Only the &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;co_varnames&lt;/span&gt;&lt;/code&gt;
work for &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;inspect&lt;/span&gt;&lt;/code&gt; was going in that direction, and this has slowed
down. It was more important to make Nuitka’s recursion more accessible
with the new options, so that was done first.&lt;/p&gt;
&lt;p&gt;And of course, the real excitement is the “type inference” work. It will
give a huge boost to Nuitka, and I am happy that it seems to go well.
With this in place, new benchmarks may make sense. I am working on
getting it off the ground, so other people can work on it too. My idea
of &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;ctypes&lt;/span&gt;&lt;/code&gt; native calls may become true sooner than expected. To
support that, I would like to add more tools to make sure we discover
changes earlier on, checking the XML representations of tests to
discover improvements and regressions more clearly.&lt;/p&gt;
&lt;/section&gt;
&lt;/section&gt;
</content>
    <link href="https://nuitka.net/posts/nuitka-release-0317.html" rel="alternate"/>
    <summary>This is to inform you about the new stable release of Nuitka. It is the extremely compatible Python compiler,
“download now”.</summary>
    <category term="compiler" label="compiler"/>
    <category term="Python" label="Python"/>
    <category term="Nuitka" label="Nuitka"/>
    <published>2012-01-09T07:59:00+00:00</published>
  </entry>
  <entry>
    <id>https://nuitka.net/posts/nuitka-release-0318.html</id>
    <title>Nuitka Release 0.3.18</title>
    <updated>2012-01-14T11:34:00+00:00</updated>
    <author>
      <name>Kay Hayen</name>
    </author>
    <content type="html">&lt;section id="nuitka-release-0-3-18"&gt;

&lt;p&gt;This is to inform you about the new stable release of &lt;a class="reference external" href="https://nuitka.net"&gt;Nuitka&lt;/a&gt;. It is the extremely compatible Python compiler,
&lt;a class="reference external" href="/doc/download.html"&gt;“download now”&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;This is to inform you about the new stable release of Nuitka. This time
there are a few bug fixes, and the important step that triggered the
release: Nuitka has entered Debian Unstable. So you if want, you will
get stable Nuitka releases from now on via &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;apt-get&lt;/span&gt; &lt;span class="pre"&gt;install&lt;/span&gt; &lt;span class="pre"&gt;nuitka&lt;/span&gt;&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The release cycle was too short to have much focus. It merely includes
fixes, which were available as hot fixes, and some additional
optimization and node tree cleanups, as well as source cleanups. But not
much else.&lt;/p&gt;
&lt;section id="bug-fixes"&gt;
&lt;h2&gt;Bug fixes&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;Conditional statements with both branches empty were not optimized
away in all cases, triggering an assertion of code generation.
Released as 0.3.17a hot fix already.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Nuitka was considering directories to contain packages that had no
“__init__.py” which could lead to errors when it couldn’t find the
package later in the compilation process. Released as 0.3.17a hot fix
already.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;When providing &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;locals()&lt;/span&gt;&lt;/code&gt; to &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;exec&lt;/span&gt;&lt;/code&gt; statements, this was not
making the &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;locals()&lt;/span&gt;&lt;/code&gt; writable. The logic to detect the case that
default value is used (&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;None&lt;/span&gt;&lt;/code&gt;) and be pessimistic about it, didn’t
consider the actual value &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;locals()&lt;/span&gt;&lt;/code&gt;. Released as 0.3.17b hot fix
already.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Compatibility Fix: When no defaults are given, CPython uses &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;None&lt;/span&gt;&lt;/code&gt;
for &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;func.func_defaults&lt;/span&gt;&lt;/code&gt;, but Nuitka had been using &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;None&lt;/span&gt;&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section id="optimization"&gt;
&lt;h2&gt;Optimization&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;If the condition of assert statements can be predicted, these are now
optimized in a static raise or removed.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;For built-in name references, there is now dedicated code to look
them up, that doesn’t check the module level at all. Currently these
are used in only a few cases though.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Cleaner code is generated for the simple case of &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;print&lt;/span&gt;&lt;/code&gt;
statements. This is not only faster code, it’s also more readable.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section id="cleanups"&gt;
&lt;h2&gt;Cleanups&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Removed the &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;CPythonStatementAssert&lt;/span&gt;&lt;/code&gt; node.&lt;/p&gt;
&lt;p&gt;It’s not needed, instead at tree building, assert statements are
converted to conditional statements with the asserted condition
result inverted and a raise statement with &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;AssertionError&lt;/span&gt;&lt;/code&gt; and the
assertion argument.&lt;/p&gt;
&lt;p&gt;This allowed to remove code and complexity from the subsequent steps
of Nuitka, and enabled existing optimization to work on assert
statements as well.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Moved built-in exception names and built-in names to a new module
&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;nuitka.Builtins&lt;/span&gt;&lt;/code&gt; instead of having in other places. This was
previously a bit spread-out and misplaced.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Added cumulative &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;tags&lt;/span&gt;&lt;/code&gt; to node classes for use in checks. Use it
annotate which node kinds to visit in e.g. per scope finalization
steps. That avoids kinds and class checks.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;New node for built-in name lookups&lt;/p&gt;
&lt;p&gt;This allowed to remove tricks played with adding module variable
lookups for &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;staticmethod&lt;/span&gt;&lt;/code&gt; when adding them for &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;__new__&lt;/span&gt;&lt;/code&gt; or
module variable lookups for &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;str&lt;/span&gt;&lt;/code&gt; when predicting the result of
&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;type('a')&lt;/span&gt;&lt;/code&gt;, which was unlikely to cause a problem, but an
important &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;TODO&lt;/span&gt;&lt;/code&gt; item still.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section id="organisational"&gt;
&lt;h2&gt;Organisational&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;The &lt;a class="reference external" href="https://nuitka.net/doc/download.html"&gt;“Download”&lt;/a&gt; page is now
finally updated for releases automatically.&lt;/p&gt;
&lt;p&gt;Up to this release, I had to manually edit that page, but now
mastered the art of upload via XMLRCP and a Python script, so that
don’t loose as much time with editing, checking it, etc.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The Debian package is backportable to Ubuntu Natty, Maverick,
Oneiric, I expect to make a separate announcement with links to
packages.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Made sure the test runners worth with bare &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;python2.6&lt;/span&gt;&lt;/code&gt; as well.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section id="new-tests"&gt;
&lt;h2&gt;New Tests&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;Added some tests intended for type inference development.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section id="summary"&gt;
&lt;h2&gt;Summary&lt;/h2&gt;
&lt;p&gt;This releases contains not as much changes as others, mostly because
it’s the intended base for a Debian upload.&lt;/p&gt;
&lt;p&gt;The &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;exec&lt;/span&gt;&lt;/code&gt; fix was detected by continued work on the branch
&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;feature/minimize_CPython26_tests_diff&lt;/span&gt;&lt;/code&gt; branch, but that work is now
complete.&lt;/p&gt;
&lt;p&gt;It is being made pretty (many git rebase iterations) with lots of Issues
being added to the bug tracker and referenced for each change. The
intention is to have a clean commits repository with the changed made.&lt;/p&gt;
&lt;p&gt;But of course, the real excitement is the “type inference” work. It will
give a huge boost to Nuitka. With this in place, new benchmarks may make
sense. I am working on getting it off the ground, but also to make us
more efficient.&lt;/p&gt;
&lt;p&gt;So when I learn something. e.g. &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;assert&lt;/span&gt;&lt;/code&gt; is not special, I apply it to
the &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;develop&lt;/span&gt;&lt;/code&gt; branch immediately, to keep the differences as small as
possible, and to immediately benefit from such improvements.&lt;/p&gt;
&lt;/section&gt;
&lt;/section&gt;
</content>
    <link href="https://nuitka.net/posts/nuitka-release-0318.html" rel="alternate"/>
    <summary>This is to inform you about the new stable release of Nuitka. It is the extremely compatible Python compiler,
“download now”.</summary>
    <category term="compiler" label="compiler"/>
    <category term="Python" label="Python"/>
    <category term="Nuitka" label="Nuitka"/>
    <published>2012-01-14T11:34:00+00:00</published>
  </entry>
  <entry>
    <id>https://nuitka.net/posts/static-site-generator.html</id>
    <title>Static Site Generator</title>
    <updated>2012-01-26T07:32:00+00:00</updated>
    <author>
      <name>Kay Hayen</name>
    </author>
    <content type="html">&lt;section id="static-site-generator"&gt;

&lt;p&gt;Hello,&lt;/p&gt;
&lt;p&gt;somehow triggered by reading about Mynth, and the re-post of the last
release announcement on my feed, just because I added a missing category
to the post, I am wondering what it takes to achieve the following:&lt;/p&gt;
&lt;blockquote&gt;
&lt;div&gt;&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;Edit the pages site as ReST (reStructured text) document with
links inside&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Edit posts as single ReST files&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Have it look decent and provide feeds, proper caching headers,
etc.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Generate a static site from with, with more control over what kind
of updates makes it into the feed.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;&lt;/blockquote&gt;
&lt;p&gt;I am currently very annoyed, because:&lt;/p&gt;
&lt;blockquote&gt;
&lt;div&gt;&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;I would normally generate code examples now with “rst2html” and
replace the existing Wordpress plugin that renders in JavaScript.
Except I cannot without re-posting all these articles, or removing
the “python” tag from them.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The documentation of Nuitka is in ReST and I even intend to expand
it with UML diagrams generated from text. Making the cross to HTML
content is difficult.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Some pages only replicate content from the User or Developer
Manual, keeping those updated, in sync, etc. is a dull thing to
do.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Extending Wordpress in Python is not feasible. And in php, I doubt
I want to master.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;&lt;/blockquote&gt;
&lt;p&gt;Other stuff in favor of it, is that Wordpress or any CMS needs more
memory and more time to process than static pages of course. I can’t
right now let anyone fork and edit the pages in a practical manner. So
while for User Manual and Developer Manual of Nuitka I will get
corrections, for the website it’s not happening.&lt;/p&gt;
&lt;p&gt;Is Mynth an appropriate intermediate step? Do I really want to learn one
of these strange templating languages or even consider software that has
no Debian package. I never considered “virtualenv” and “pip” much of
options to run software on a website. I guess I am more tied to Debian
than to Python still.&lt;/p&gt;
&lt;p&gt;Over the last months I have occasionally looked at Pyramids, but it
seems overly complex, if all you want is to simplify the authoring. I
have seen that e.g. Trac supports ReST as an exception, but that feels
too little for a hefty software like that.&lt;/p&gt;
&lt;p&gt;I may end up with using ReST to generate HTML which is then uploaded via
XMLRPC to Wordpress. Won’t give me the “static” benefits. Won’t solve
the post update problem. But at least will let me edit more easily.&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;Yours,&lt;/div&gt;
&lt;div class="line"&gt;Kay&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
</content>
    <link href="https://nuitka.net/posts/static-site-generator.html" rel="alternate"/>
    <summary>Hello,</summary>
    <category term="Python" label="Python"/>
    <published>2012-01-26T07:32:00+00:00</published>
  </entry>
  <entry>
    <id>https://nuitka.net/posts/nuitka-release-0319.html</id>
    <title>Nuitka Release 0.3.19</title>
    <updated>2012-01-26T20:49:00+00:00</updated>
    <author>
      <name>Kay Hayen</name>
    </author>
    <content type="html">&lt;section id="nuitka-release-0-3-19"&gt;

&lt;p&gt;This is to inform you about the new stable release of &lt;a class="reference external" href="https://nuitka.net"&gt;Nuitka&lt;/a&gt;. It is the extremely compatible Python compiler,
&lt;a class="reference external" href="/doc/download.html"&gt;“download now”&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;This time there are a few bug fixes, major cleanups, more Python3
support, and even new features. A lot things in this are justifying a
new release.&lt;/p&gt;
&lt;section id="bug-fixes"&gt;
&lt;h2&gt;Bug fixes&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;The man pages of &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;nuitka&lt;/span&gt;&lt;/code&gt; and &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;nuitka-python&lt;/span&gt;&lt;/code&gt; had no special
layout for the option groups and broken whitespace for
&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;--recurse-to&lt;/span&gt;&lt;/code&gt; option. Also &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;--g++-only&lt;/span&gt;&lt;/code&gt; was only partially bold.
Released as 0.3.18.1 hot fix already.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The command line length improvement we made to Scons for Windows was
not portable to Python2.6. Released as 0.3.18.2 hot fix already.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Code to detect already considered packages detection was not portable
to Windows, for one case, there was still a use of &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;/&lt;/span&gt;&lt;/code&gt; instead of
using a &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;joinpath&lt;/span&gt;&lt;/code&gt; call. Released as 0.3.18.3 already.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;A call to the range built-in with no arguments would crash the
compiler, see Released as 0.3.18.4 already.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Compatibility Fix: When rich comparison operators returned false
value other &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;False&lt;/span&gt;&lt;/code&gt;, for comparison chains, these would not be
used, but &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;False&lt;/span&gt;&lt;/code&gt; instead, see .&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The support for &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;__import__&lt;/span&gt;&lt;/code&gt; didn’t cover keyword arguments, these
were simply ignored. Fixed, but no warning is given yet.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section id="new-features"&gt;
&lt;h2&gt;New Features&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;A new option has been added, one can now specify
&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;--recurse-directory&lt;/span&gt;&lt;/code&gt; and Nuitka will attempt to embed these
modules even if not obviously imported. This is not yet working
perfect yet, but will receive future improvements.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Added support for the &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;exec&lt;/span&gt;&lt;/code&gt; built-in of Python3, this enables us
to run one more basic test, &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;GlobalStatement.py&lt;/span&gt;&lt;/code&gt; with Python3. The
test &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;ExecEval.py&lt;/span&gt;&lt;/code&gt; nearly works now.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section id="optimization"&gt;
&lt;h2&gt;Optimization&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;The no arguments &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;range()&lt;/span&gt;&lt;/code&gt; call now optimized into the static
CPython exception it raises.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Parts of comparison chains with constant arguments are now optimized
away.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section id="cleanups"&gt;
&lt;h2&gt;Cleanups&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Simplified the &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;CPythonExpressionComparison&lt;/span&gt;&lt;/code&gt; node, it now always
has only 2 operands.&lt;/p&gt;
&lt;p&gt;If there are more, the so called “comparison chain”, it’s done via
&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;and&lt;/span&gt;&lt;/code&gt; with assignments to temporary variables, which are expressed
by a new node type &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;CPythonExpressionTempVariableRef&lt;/span&gt;&lt;/code&gt;. This allowed
to remove &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;expression_temps&lt;/span&gt;&lt;/code&gt; from C++ code templates and
generation, reducing the overall complexity.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;When executing a module (&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;--execute&lt;/span&gt;&lt;/code&gt; but not &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;--exe&lt;/span&gt;&lt;/code&gt;), no longer
does Nuitka import it into itself, instead a new interpreter is
launched with a fresh environment.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The calls to the variadic &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;MAKE_TUPLE&lt;/span&gt;&lt;/code&gt; were replaced with calls the
&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;MAKE_TUPLExx&lt;/span&gt;&lt;/code&gt; (where &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;xx&lt;/span&gt;&lt;/code&gt; is the number of arguments), that are
generated on a as-needed basis. This gives more readable code,
because no &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;EVAL_ORDERED_xx&lt;/span&gt;&lt;/code&gt; is needed at call site anymore.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Many node classes have moved to new modules in &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;nuitka.nodes&lt;/span&gt;&lt;/code&gt; and
grouped by theme. That makes them more accessible.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The choosing of the debug python has moved from Scons to Nuitka
itself. That way it can respect the &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;sys.abiflags&lt;/span&gt;&lt;/code&gt; and works with
Python3.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The replacing of &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;.py&lt;/span&gt;&lt;/code&gt; in filenames was made more robust. No longer
is &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;str.replace&lt;/span&gt;&lt;/code&gt; used, but instead proper means to assure that
having &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;.py&lt;/span&gt;&lt;/code&gt; as other parts of the filenames won’t be a trouble.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Module recursion was changed into its own module, instead of being
hidden in the optimization that considers import statements.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;As always, some PyLint work, and some minor &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;TODO&lt;/span&gt;&lt;/code&gt; were solved.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section id="organisational"&gt;
&lt;h2&gt;Organisational&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;Added more information to the &lt;a class="reference external" href="https://nuitka.net/doc/developer-manual.html"&gt;Developer Manual&lt;/a&gt;, e.g. documenting
the tree changes for &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;assert&lt;/span&gt;&lt;/code&gt; to become a conditional statement
with a raise statement, etc.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The Debian package is as of this version verified to be installable
and functional on to Ubuntu Natty, Maverick, Oneiric, and Precise.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Added support to specify the binary under test with a &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;NUITKA&lt;/span&gt;&lt;/code&gt;
environment, so the test framework can run with installed version of
Nuitka too.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Made sure the test runners work under Windows as well. Required
making them more portable. And a workaround for &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;os.execl&lt;/span&gt;&lt;/code&gt; not
propagating exit codes under Windows.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;For windows target the MinGW library is now linked statically. That
means there is no requirement for MinGW to be in the &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;PATH&lt;/span&gt;&lt;/code&gt; or even
installed to execute the binary.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section id="new-tests"&gt;
&lt;h2&gt;New Tests&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;The &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;basic&lt;/span&gt;&lt;/code&gt;, &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;programs&lt;/span&gt;&lt;/code&gt;, &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;syntax&lt;/span&gt;&lt;/code&gt;, and &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;reflected&lt;/span&gt;&lt;/code&gt; were made
executable under Windows. Occasionally this meant to make the test
runners more portable, or to work around limitations.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Added test to cover return values of rich comparisons in comparison
chains, and order of argument evaluation for comparison chains.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;Referencing.py&lt;/span&gt;&lt;/code&gt; test was made portable to Python3.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Cover no arguments &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;range()&lt;/span&gt;&lt;/code&gt; exception as well.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Added test to demonstrate that &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;--recurse-directory&lt;/span&gt;&lt;/code&gt; actually
works. This is using an &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;__import__&lt;/span&gt;&lt;/code&gt; that cannot be predicted at
run time (yet).&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The created source package is now tested on pbuilder chroots to be
pass installation and the basic tests, in addition to the full tests
during package build time on these chroots. This will make sure, that
Nuitka works fine on Ubuntu Natty and doesn’t break without notice.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section id="summary"&gt;
&lt;h2&gt;Summary&lt;/h2&gt;
&lt;p&gt;This releases contains many changes. The “temporary variable ref” and
“assignment expression” work is ground breaking. I foresee that it will
lead to even more simplifications of code generation in the future, when
e.g. in-place assignments can be reduced to assignments to temporary
variables and conditional statements.&lt;/p&gt;
&lt;p&gt;While there were many improvements related to Windows support and fixing
portability bugs, or the Debian package, the real focus is the
optimization work, which will ultimately end with “value propagation”
working.&lt;/p&gt;
&lt;p&gt;These are the real focus. The old comparison chain handling was a big
wart. Working, but no way understood by any form of analysis in Nuitka.
Now they have a structure which makes their code generation based on
semantics and allows for future optimization to see through them.&lt;/p&gt;
&lt;p&gt;Going down this route is an important preparatory step. And there will
be more work like this needed. Consider e.g. handling of in-place
assignments. With an “assignment expression” to a “temporary variable
ref”, these become the same as user code using such a variable. There
will be more of these to find.&lt;/p&gt;
&lt;p&gt;So, that is where the focus is. The release now was mostly aiming at
getting involved fixes out. The bug fixed by comparison chain reworking,
and the &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;__import__&lt;/span&gt;&lt;/code&gt; related one, were not suitable for hot fix
releases, so that is why the 0.3.19 release had to occur now. But with
plugin support, with this comparison chain cleanup, with improved
Python3 support, and so on, there was plenty of good stuff already, also
worth to get out.&lt;/p&gt;
&lt;/section&gt;
&lt;/section&gt;
</content>
    <link href="https://nuitka.net/posts/nuitka-release-0319.html" rel="alternate"/>
    <summary>This is to inform you about the new stable release of Nuitka. It is the extremely compatible Python compiler,
“download now”.</summary>
    <category term="compiler" label="compiler"/>
    <category term="Python" label="Python"/>
    <category term="Nuitka" label="Nuitka"/>
    <published>2012-01-26T20:49:00+00:00</published>
  </entry>
  <entry>
    <id>https://nuitka.net/posts/ubuntu-packages-for-nuitka.html</id>
    <title>Ubuntu Packages for Nuitka</title>
    <updated>2012-01-31T08:25:00+00:00</updated>
    <author>
      <name>Kay Hayen</name>
    </author>
    <content type="html">&lt;section id="ubuntu-packages-for-nuitka"&gt;

&lt;p&gt;Hello there,&lt;/p&gt;
&lt;p&gt;as I previously said, I will make these a separate announcement. Thanks
to the NeuroDebian project build infrastructure, there is Nuitka
packages for the Ubuntu versions back to Maverick, Natty, and Oneiric.&lt;/p&gt;
&lt;p&gt;Please see the page &lt;a class="reference external" href="/pages/overview.html"&gt;What is Nuitka?&lt;/a&gt; for
clarification of what it is now and what it wants to be.&lt;/p&gt;
&lt;p&gt;You may use the apt sources to track Nuitka or download the packages
from the page where I offer the &lt;a class="reference external" href="/pages/download.html"&gt;latest version here&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Note: In fact, it’s 0.3.19.1 now, which includes a hotfix release made
after 0.3.19. The same is in Debian Unstable right now, waiting to
propagate into Debian Testing, where there is still 0.3.18 living at
this time.&lt;/p&gt;
&lt;p&gt;I would appreciate feedback on these.&lt;/p&gt;
&lt;p&gt;Thanks in advance, Kay&lt;/p&gt;
&lt;/section&gt;
</content>
    <link href="https://nuitka.net/posts/ubuntu-packages-for-nuitka.html" rel="alternate"/>
    <summary>Hello there,</summary>
    <category term="Nuitka" label="Nuitka"/>
    <category term="Python" label="Python"/>
    <published>2012-01-31T08:25:00+00:00</published>
  </entry>
  <entry>
    <id>https://nuitka.net/posts/award-winning-cat.html</id>
    <title>Award winning cat</title>
    <updated>2012-02-20T12:51:00+00:00</updated>
    <author>
      <name>Kay Hayen</name>
    </author>
    <content type="html">&lt;section id="award-winning-cat"&gt;

&lt;figure class="align-default"&gt;
&lt;a class="reference external image-reference" href="/_images/Katze_Medaille.jpg"&gt;&lt;img alt="Image of cat Muska with a medaille." src="../_images/Katze_Medaille.jpg" style="width: 80%;" /&gt;&lt;/a&gt;
&lt;/figure&gt;
&lt;p&gt;The sweetness phase is over. At least in that instant. :-)&lt;/p&gt;
&lt;/section&gt;
</content>
    <link href="https://nuitka.net/posts/award-winning-cat.html" rel="alternate"/>
    <summary>The sweetness phase is over. At least in that instant. :-)</summary>
    <category term="family" label="family"/>
    <published>2012-02-20T12:51:00+00:00</published>
  </entry>
  <entry>
    <id>https://nuitka.net/posts/nuitka-release-0320.html</id>
    <title>Nuitka Release 0.3.20</title>
    <updated>2012-02-27T22:48:00+00:00</updated>
    <author>
      <name>Kay Hayen</name>
    </author>
    <content type="html">&lt;section id="nuitka-release-0-3-20"&gt;

&lt;p&gt;This is to inform you about the new stable release of &lt;a class="reference external" href="https://nuitka.net"&gt;Nuitka&lt;/a&gt;. It is the extremely compatible Python compiler,
&lt;a class="reference external" href="/doc/download.html"&gt;“download now”&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;This time there are a few bug fixes and some really major cleanups, lots
of new optimization and preparations for more. And then there is a new
compiler clang and a new platform supported. macOS X appears to work
mostly, thanks for the patches from Pete Hunt.&lt;/p&gt;
&lt;section id="bug-fixes"&gt;
&lt;h2&gt;Bug fixes&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;The use of a local variable name as an expression was not covered and
lead to a compiler crash. Totally amazing, but true, nothing in the
test suite of CPython covered this. Fixed in release 0.3.19.1
already.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The use of a closure variable name as an expression was not covered
as well. And in this case corrupted the reference count. Fixed in
release 0.3.19.1 already.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;from&lt;/span&gt; &lt;span class="pre"&gt;x&lt;/span&gt; &lt;span class="pre"&gt;import&lt;/span&gt; &lt;span class="pre"&gt;*&lt;/span&gt;&lt;/code&gt; attempted to respect &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;__all__&lt;/span&gt;&lt;/code&gt; but failed
to do so. Fixed in release 0.3.19.2 already.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;from&lt;/span&gt; &lt;span class="pre"&gt;x&lt;/span&gt; &lt;span class="pre"&gt;import&lt;/span&gt; &lt;span class="pre"&gt;*&lt;/span&gt;&lt;/code&gt; didn’t give a &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;SyntaxError&lt;/span&gt;&lt;/code&gt; when used on
Python3. Fixed in release 0.3.19.2 already.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The syntax error messages for “global for function argument name” and
“duplicate function argument name” are now identical as well.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Parameter values of generator function could cause compilation errors
when used in the closure of list contractions. Fixed.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section id="new-features"&gt;
&lt;h2&gt;New Features&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;Added support for disabling the console for Windows binaries. Thanks
for the patch go to Michael H Kent.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Enhanced Python3 support for syntax errors, these are now also
compatible.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Support for macOS X was added.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Support for using the clang compiler was added, it can be enforced
via &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;--clang&lt;/span&gt;&lt;/code&gt; option. Currently this option is mainly intended to
allow testing the “macOS X” support as good as possible under Linux.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section id="optimization"&gt;
&lt;h2&gt;Optimization&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Enhanced all optimization that previously worked on “constants” to
work on “compile time constants” instead. A “compile time constant”
can currently also be any form of a built-in name or exception
reference. It is intended to expand this in the future.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Added support for built-ins &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;bin&lt;/span&gt;&lt;/code&gt;, &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;oct&lt;/span&gt;&lt;/code&gt;, and &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;hex&lt;/span&gt;&lt;/code&gt;, which also
can be computed at compile time, if their arguments are compile time
constant.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Added support for the &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;iter&lt;/span&gt;&lt;/code&gt; built-in in both forms, one and two
arguments. These cannot be computed at compile time, but now will
execute faster.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Added support for the &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;next&lt;/span&gt;&lt;/code&gt; built-in, also in its both forms, one
and two arguments. These also cannot be computed at compile time, but
now will execute faster as well.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Added support for the &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;open&lt;/span&gt;&lt;/code&gt; built-in in all its form. We intend
for future releases to be able to track file opens for including them
into the executable if data files.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Optimize the &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;__debug__&lt;/span&gt;&lt;/code&gt; built-in constant as well. It cannot be
assigned, yet code can determine a mode of operation from it, and
apparently some code does. When compiling the mode is decided.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Optimize the &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;Ellipsis&lt;/span&gt;&lt;/code&gt; built-in constant as well. It falls in the
same category as &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;True&lt;/span&gt;&lt;/code&gt;, &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;False&lt;/span&gt;&lt;/code&gt;, &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;None&lt;/span&gt;&lt;/code&gt;, i.e. names of
built-in constants that a singletons.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Added support for anonymous built-in references, i.e. built-ins which
have names that are not normally accessible. An example is
&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;type(None)&lt;/span&gt;&lt;/code&gt; which is not accessible from anywhere. Other examples
of such names are &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;compiled_method_or_function&lt;/span&gt;&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Having these as represented internally, and flagged as “compile time
constants”, allows the compiler to make more compile time
optimization and to generate more efficient C++ code for it that
won’t e.g. call the &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;type&lt;/span&gt;&lt;/code&gt; built-in with &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;None&lt;/span&gt;&lt;/code&gt; as an argument.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;All built-in names used in the program are now converted to “built-in
name references” in a first step. Unsupported built-ins like e.g.
&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;zip&lt;/span&gt;&lt;/code&gt;, for which Nuitka has no own code or understanding yet,
remained as “module variables”, which made access to them slow, and
difficult to recognize.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Added optimization for module attributes &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;__file__&lt;/span&gt;&lt;/code&gt;, &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;__doc__&lt;/span&gt;&lt;/code&gt;
and &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;__package__&lt;/span&gt;&lt;/code&gt; if they are read only. It’s the same as was done
for &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;__name__&lt;/span&gt;&lt;/code&gt; so far only.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Added optimization for slices and subscripts of “compile time
constant” values. These will play a more important role, once value
propagation makes them more frequent.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section id="organisational"&gt;
&lt;h2&gt;Organisational&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;Created a “change log” from the previous release announcements. It’s
as ReStructured Text and converted to PDF for the release as well,
but I chose not to include that in Debian, because it’s so easy to
generate the PDF on that yourself.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The posting of release announcements is now prepared by a script that
converts the ReStructured Text to HTML and adds it to Wordpress as a
draft posting or updates it, until it’s release time. Simple, sweet
and elegant.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section id="cleanups"&gt;
&lt;h2&gt;Cleanups&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Split out the &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;nuitka.nodes.Nodes&lt;/span&gt;&lt;/code&gt; module into many topic nodes, so
that there are now &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;nuitka.nodes.BoolNodes&lt;/span&gt;&lt;/code&gt; or
&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;nuitka.nodes.LoopNodes&lt;/span&gt;&lt;/code&gt; to host nodes of similar kinds, so that it
is now cleaner.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Split &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;del&lt;/span&gt;&lt;/code&gt; statements into their own node kind, and use much
simpler node structures for them. The following blocks are absolutely
the same:&lt;/p&gt;
&lt;div class="highlight-python notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;del&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="highlight-python notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;del&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;span class="k"&gt;del&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;
&lt;span class="k"&gt;del&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;So that’s now represented in the node tree. And even more complex
looking cases, like this one, also the same:&lt;/p&gt;
&lt;div class="highlight-python notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;del&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;d&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;This one gives a different parse tree, but the same bytecode. And so
Nuitka need no longer concern itself with this at all, and can remove
the tuple from the parse tree immediately. That makes them easy to
handle. As you may have noted already, it also means, there is no way
to enforce that two things are deleted or none at all.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Turned the function and class builder statements into mere assignment
statements, where defaults and base classes are handled by wrapping
expressions.&lt;/p&gt;
&lt;p&gt;Previously they are also kind of assignment statements too, which is
not needed. Now they were reduced to only handle the &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;bases&lt;/span&gt;&lt;/code&gt; for
classes and the &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;defaults&lt;/span&gt;&lt;/code&gt; for functions and make optional.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Refactored the decorator handling to the tree building stage,
presenting them as function calls on “function body expression” or
class body expression”.&lt;/p&gt;
&lt;p&gt;This allowed to remove the special code for decorators from code
generation and C++ templates, making decorations easy subjects for
future optimization, as they practically are now just function calls.&lt;/p&gt;
&lt;div class="highlight-python notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nd"&gt;@some_classdecorator&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;C&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="nd"&gt;@staticmethod&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;f&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
        &lt;span class="k"&gt;pass&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;It’s just a different form of writing things. Nothing requires the
implementation of decorators, it’s just functions calls with function
bodies before the assignment.&lt;/p&gt;
&lt;p&gt;The following is only similar:&lt;/p&gt;
&lt;div class="highlight-python notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;C&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;f&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
        &lt;span class="k"&gt;pass&lt;/span&gt;

    &lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;staticmethod&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;


&lt;span class="n"&gt;C&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;some_classdecorator&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;C&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;It’s only similar, because the assignment to an intermediate value of
&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;C&lt;/span&gt;&lt;/code&gt; and &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;f&lt;/span&gt;&lt;/code&gt; is not done, and if an exception was raised by the
decoration, that name could persist. For Nuitka, the function and
class body, before having a name, are an expression, and so can of
course be passed to decorators already.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The in-place assignments statements are now handled using temporary
variable blocks&lt;/p&gt;
&lt;p&gt;Adding support for scoped temporary variables and references to them,
it was possible to re-formulate in-place assignments expressions as
normal look-ups, in-place operation call and then assignment
statement. This allowed to remove static templates and will yield
even better generated code in the future.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The for loop used to have has a “source” expression as child, and the
iterator over it was only taken at the code generation level, so that
step was therefore invisible to optimization. Moved it to tree
building stage instead, where optimization can work on it then.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Tree building now generally allows statement sequences to be &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;None&lt;/span&gt;&lt;/code&gt;
everywhere, and pass statements are immediately eliminated from them
immediately. Empty statement sequences are now forbidden to exist.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Moved the optimization for &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;__name__&lt;/span&gt;&lt;/code&gt; to compute node of variable
references, where it doesn’t need anything complex to replace with
the constant value if it’s only read.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Added new bases classes and mix-in classes dedicated to expressions,
giving a place for some defaults.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Made the built-in code more reusable.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section id="new-tests"&gt;
&lt;h2&gt;New Tests&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;Added some more diagnostic tests about complex assignment and &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;del&lt;/span&gt;&lt;/code&gt;
statements.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Added syntax test for star import on function level, that must fail
on Python3.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Added syntax test for duplicate argument name.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Added syntax test for global on a function argument name.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section id="summary"&gt;
&lt;h2&gt;Summary&lt;/h2&gt;
&lt;p&gt;The decorator and building changes, the assignment changes, and the node
cleanups are all very important progress for the type inference work,
because they remove special casing the that previously would have been
required. Lambdas and functions now really are the same thing right
after tree building. The in-place assignments are now merely done using
standard assignment code, the built functions and classes are now
assigned to names in assignment statements, much &lt;em&gt;more&lt;/em&gt; consistency
there.&lt;/p&gt;
&lt;p&gt;Yet, even more work will be needed in the same direction. There may e.g.
be work required to cover &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;with&lt;/span&gt;&lt;/code&gt; statements as well. And assignments
will become no more complex than unpacking from a temporary variable.&lt;/p&gt;
&lt;p&gt;For this release, there is only minimal progress on the Python3 front,
despite the syntax support, which is only minuscule progress. The
remaining tasks appear all more or less difficult work that I don’t want
to touch now.&lt;/p&gt;
&lt;p&gt;There are still remaining steps, but we can foresee that a release may
be done that finally actually does type inference and becomes the
effective Python compiler this project is all about.&lt;/p&gt;
&lt;/section&gt;
&lt;/section&gt;
</content>
    <link href="https://nuitka.net/posts/nuitka-release-0320.html" rel="alternate"/>
    <summary>This is to inform you about the new stable release of Nuitka. It is the extremely compatible Python compiler,
“download now”.</summary>
    <category term="compiler" label="compiler"/>
    <category term="Python" label="Python"/>
    <category term="Nuitka" label="Nuitka"/>
    <published>2012-02-27T22:48:00+00:00</published>
  </entry>
  <entry>
    <id>https://nuitka.net/posts/nuitka-release-0321.html</id>
    <title>Nuitka Release 0.3.21</title>
    <updated>2012-04-13T10:19:00+00:00</updated>
    <author>
      <name>Kay Hayen</name>
    </author>
    <content type="html">&lt;section id="nuitka-release-0-3-21"&gt;

&lt;p&gt;This is to inform you about the new stable release of &lt;a class="reference external" href="https://nuitka.net"&gt;Nuitka&lt;/a&gt;. It is the extremely compatible Python compiler,
&lt;a class="reference external" href="/doc/download.html"&gt;“download now”&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;This releases contains some really major enhancements, all heading
towards enabling value propagation inside Nuitka. Assignments of all
forms are now all simple and explicit, and as a result, now it will be
easy to start tracking them.&lt;/p&gt;
&lt;p&gt;Contractions have become functions internally, with statements use
temporary variables, complex unpacking statement were reduced to more
simple ones, etc.&lt;/p&gt;
&lt;p&gt;Also there are the usual few small bug fixes, and a bunch of
organisational improvements, that make the release complete.&lt;/p&gt;
&lt;section id="bug-fixes"&gt;
&lt;h2&gt;Bug fixes&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;The built-in &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;next&lt;/span&gt;&lt;/code&gt; could causes a program crash when iterating
past the end of an iterator. Fixed in 0.3.20.1 already.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;set&lt;/span&gt;&lt;/code&gt; constants could cause a compiler error, as that type was
not considered in the “mutable” check yet. Fixed in 0.3.20.2 already.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Performance regression. Optimize expression for exception types
caught as well again, this was lost in last release.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Functions that contain &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;exec&lt;/span&gt;&lt;/code&gt;, are supposed to have a writable
locals. But when removing that &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;exec&lt;/span&gt;&lt;/code&gt; statement as part of
optimization, this property of the function could get lost.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The so called “overflow functions” are once again correctly handled.
These once were left behind in some refactoring and had not been
repaired until now. An overflow function is a nested function with an
&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;exec&lt;/span&gt;&lt;/code&gt; or a star import.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The syntax error for &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;return&lt;/span&gt;&lt;/code&gt; outside of a function, was not given,
instead the code returned at run time. Fixed to raise a
&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;SyntaxError&lt;/span&gt;&lt;/code&gt; at compile time.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section id="optimization"&gt;
&lt;h2&gt;Optimization&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Avoid &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;tuple&lt;/span&gt;&lt;/code&gt; objects to be created when catching multiple
exception types, instead call exception match check function multiple
times.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Removal of dead code following &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;break&lt;/span&gt;&lt;/code&gt;, &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;continue&lt;/span&gt;&lt;/code&gt;, &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;return&lt;/span&gt;&lt;/code&gt;,
and &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;raise&lt;/span&gt;&lt;/code&gt;. Code that follows these statements, or conditional
statements, where all branches end with it.&lt;/p&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;注解&lt;/p&gt;
&lt;p&gt;These may not actually occur often in actual code, but future
optimization may produce them more frequently, and their removal
may in turn make other possible optimization.&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Detect module variables as “read only” after all writes have been
detected to not be executed as removed. Previously the “read only
indicator” was determined only once and then stayed the same.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Expanded conditional statement optimization to detect cases, where
condition is a compile time constant, not just a constant value.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Optimize away assignments from a variable to the same variable, they
have no effect. The potential side effect of accessing the variable
is left intact though, so exceptions will be raised still.&lt;/p&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;注解&lt;/p&gt;
&lt;p&gt;An exception is where &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;len&lt;/span&gt; &lt;span class="pre"&gt;=&lt;/span&gt; &lt;span class="pre"&gt;len&lt;/span&gt;&lt;/code&gt; actually does have an impact,
because that variable becomes assignable. The “compile itself”
test of Nuitka found that to happen with &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;long&lt;/span&gt;&lt;/code&gt; from the
&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;nuitka.__past__&lt;/span&gt;&lt;/code&gt; module.&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Created Python3 variant of quick &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;unicode&lt;/span&gt;&lt;/code&gt; string access, there was
no such thing in the CPython C/API, but we make the distinction in
the source code, so it makes sense to have it.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Created an optimized implementation for the built-in &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;iter&lt;/span&gt;&lt;/code&gt; with 2
parameters as well. This allows for slightly more efficient code to
be created with regards to reference handling, rather than using the
CPython C/API.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;For all types of variable assigned in the generated code, there are
now methods that accept already taken references or not, and the code
generator picks the optimal variant. This avoids the drop of
references, that e.g. the local variable will insist to take.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Don’t use a “context” object for generator functions (and generator
expressions) that don’t need one. And even if it does to store e.g.
the given parameter values, avoid to have a “common context” if there
is no closure taken. This avoids useless &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;malloc&lt;/span&gt;&lt;/code&gt; calls and speeds
up repeated generator object creation.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section id="organisational"&gt;
&lt;h2&gt;Organisational&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;Changed the Scons build file database to reside in the build
directory as opposed to the current directory, not polluting it
anymore. Thanks for the patch go to Michael H Kent, very much
appreciated.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;--experimental&lt;/span&gt;&lt;/code&gt; option is no longer available outside of
checkouts of git, and even there not on stable branches (&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;master&lt;/span&gt;&lt;/code&gt;,
&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;hotfix/...&lt;/span&gt;&lt;/code&gt;). It only pollutes &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;--help&lt;/span&gt;&lt;/code&gt; output as stable
releases have no experimental code options, not even development
version will make a difference.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The binary “bin/Nuitka.py” has been removed from the git repository.
It was deprecated a while ago, not part of the distribution and
served no good use, as it was a symbolic link only anyway.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;--python-version&lt;/span&gt;&lt;/code&gt; option is applied at Nuitka start time to
re-launch Nuitka with the given Python version, to make sure that the
Python run time used for computations and link time Python versions
are the same. The allowed values are now checked (2.6, 2.7 and 3.2)
and the user gets a nice error with wrong values.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Added &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;--keep-pythonpath&lt;/span&gt;&lt;/code&gt; alias for &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;--execute-with-pythonpath&lt;/span&gt;&lt;/code&gt;
option, probably easier to remember.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Support &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;--debug&lt;/span&gt;&lt;/code&gt; with clang, so it can also be used to check the
generated code for all warnings, and perform assertions. Didn’t
report anything new.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The contents environment variable &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;CXX&lt;/span&gt;&lt;/code&gt; determines the default C++
compiler when set, so that checking with &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;CXX=g++-4.7&lt;/span&gt; &lt;span class="pre"&gt;nuitka-python&lt;/span&gt;
&lt;span class="pre"&gt;...&lt;/span&gt;&lt;/code&gt; has become supported.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;check-with-pylint&lt;/span&gt;&lt;/code&gt; script now has a real command line option
to control the display of &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;TODO&lt;/span&gt;&lt;/code&gt; items.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section id="cleanups"&gt;
&lt;h2&gt;Cleanups&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Changed complex assignments, i.e. assignments with multiple targets
to such using a temporary variable and multiple simple assignments
instead.&lt;/p&gt;
&lt;div class="highlight-python notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="highlight-python notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;_tmp&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;
&lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;_tmp&lt;/span&gt;
&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;_tmp&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;In CPython, when one assignment raises an exception, the whole thing
is aborted, so the complexity of having multiple targets is no more
needed, now that we have temporary variables in a block.&lt;/p&gt;
&lt;p&gt;All that was really needed, was to evaluate the complete source
expression only once, but that made code generation contain ugly
loops that are no more needed.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Changed unpacking assignments to use temporary variables. Code like
this:&lt;/p&gt;
&lt;div class="highlight-python notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Is handled more like this:&lt;/p&gt;
&lt;div class="highlight-python notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;_tmp_iter&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;iter&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;_tmp1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;next&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;_tmp_iter&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;_tmp2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;next&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;_tmp_iter&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="n"&gt;finished&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;_tmp_iter&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;raise&lt;/span&gt; &lt;span class="ne"&gt;ValueError&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;too many values to unpack&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;_tmp1&lt;/span&gt;
&lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;_tmp2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;In reality, not really &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;next&lt;/span&gt;&lt;/code&gt; is used, as it wouldn’t raise the
correct exception for unpacking, and the &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;finished&lt;/span&gt;&lt;/code&gt; check is more
condensed into it.&lt;/p&gt;
&lt;p&gt;Generally this cleanup allowed that the &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;AssignTargetTuple&lt;/span&gt;&lt;/code&gt; and
associated code generation was removed, and in the future value
propagation may optimize these &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;next&lt;/span&gt;&lt;/code&gt; and &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;iter&lt;/span&gt;&lt;/code&gt; calls away where
possible. At this time, this is not done yet.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Exception handlers assign caught exception value through assignment
statement.&lt;/p&gt;
&lt;p&gt;Previously the code generated for assigning from the caught exception
was not considered part of the handler. It now is the first statement
of an exception handler or not present, this way it may be optimized
as well.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Exception handlers now explicitly catch more than one type.&lt;/p&gt;
&lt;p&gt;Catching multiple types worked by merits of the created tuple object
working with the Python C/API function called, but that was not
explicit at all. Now every handler has a tuple of exceptions it
catches, which may only be one, or if None, it’s all.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Contractions are now functions as well.&lt;/p&gt;
&lt;p&gt;Contractions (list, dict, and set) are now re-formulated as function
bodies that contain for loops and conditional statements. This
allowed to remove a lot of special code that dealt with them and will
make these easier to understand for optimization and value
propagation.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Global is handled during tree building.&lt;/p&gt;
&lt;p&gt;Previously the global statement was its own node, which got removed
during the optimization phase in a dedicated early optimization that
applied its effect, and then removed the node.&lt;/p&gt;
&lt;p&gt;It was determined, that there is no reason to not immediately apply
the effect of the global variable and take closure variables and add
them to the provider of that &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;global&lt;/span&gt;&lt;/code&gt; statement, allowing to remove
the node class.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Read only module variable detection integrated to constraint
collection.&lt;/p&gt;
&lt;p&gt;The detection of read only module variables was so far done as a
separate step, which is no more necessary as the constraint
collection tracks the usages of module variables anyway, so this
separate and slow step could be removed.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section id="new-tests"&gt;
&lt;h2&gt;New Tests&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Added test to cover order of calls for complex assignments that
unpack, to see that they make a fresh iterator for each part of a
complex assignment.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Added test that unpacks in an exception catch. It worked, due to the
generic handling of assignment targets by Nuitka, and I didn’t even
know it can be done, example:&lt;/p&gt;
&lt;div class="highlight-python notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;try&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;raise&lt;/span&gt; &lt;span class="ne"&gt;ValueError&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;except&lt;/span&gt; &lt;span class="ne"&gt;ValueError&lt;/span&gt; &lt;span class="k"&gt;as&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="nb"&gt;print&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Unpacking caught exception and unpacked&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Will assign &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;a=1&lt;/span&gt;&lt;/code&gt; and &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;b=2&lt;/span&gt;&lt;/code&gt;.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Added test to cover return statements on module level and class
level, they both must give syntax errors.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Cover exceptions from accessing unassigned global names.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Added syntax test to show that star imports do not allow other names
to be imported at the same time as well.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Python3 is now also running the compile itself test successfully.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section id="summary"&gt;
&lt;h2&gt;Summary&lt;/h2&gt;
&lt;p&gt;The progress made towards value propagation and type inference is &lt;em&gt;very&lt;/em&gt;
significant, and makes those appears as if they are achievable.&lt;/p&gt;
&lt;/section&gt;
&lt;/section&gt;
</content>
    <link href="https://nuitka.net/posts/nuitka-release-0321.html" rel="alternate"/>
    <summary>This is to inform you about the new stable release of Nuitka. It is the extremely compatible Python compiler,
“download now”.</summary>
    <category term="compiler" label="compiler"/>
    <category term="Python" label="Python"/>
    <category term="Nuitka" label="Nuitka"/>
    <published>2012-04-13T10:19:00+00:00</published>
  </entry>
  <entry>
    <id>https://nuitka.net/posts/nuitka-release-0322.html</id>
    <title>Nuitka Release 0.3.22</title>
    <updated>2012-05-13T13:17:00+00:00</updated>
    <author>
      <name>Kay Hayen</name>
    </author>
    <content type="html">&lt;section id="nuitka-release-0-3-22"&gt;

&lt;p&gt;This is to inform you about the new stable release of &lt;a class="reference external" href="https://nuitka.net"&gt;Nuitka&lt;/a&gt;. It is the extremely compatible Python compiler,
&lt;a class="reference external" href="/doc/download.html"&gt;“download now”&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;This release is a continuation of the trend of previous releases, and
added more re-formulations of Python that lower the burden on code
generation and optimization.&lt;/p&gt;
&lt;p&gt;It also improves Python3 support substantially. In fact this is the
first release to not only run itself under Python3, but for Nuitka to
&lt;em&gt;compile itself&lt;/em&gt; with Nuitka under Python3, which previously only worked
for Python2. For the common language subset, it’s quite fine now.&lt;/p&gt;
&lt;section id="bug-fixes"&gt;
&lt;h2&gt;Bug fixes&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;List contractions produced extra entries on the call stack, after
they became functions, these are no more existent. That was made
possible my making frame stack entries an optional element in the
node tree, left out for list contractions.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Calling a compiled function in an exception handler cleared the
exception on return, it no longer does that.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Reference counter handling with generator &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;throw&lt;/span&gt;&lt;/code&gt; method is now
correct.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;A module “builtins” conflicted with the handling of the Python
&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;builtins&lt;/span&gt;&lt;/code&gt; module. Those now use different identifiers.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section id="new-features"&gt;
&lt;h2&gt;New Features&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;New &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;metaclass&lt;/span&gt;&lt;/code&gt; syntax for the &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;class&lt;/span&gt;&lt;/code&gt; statement works, and the
old &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;__metaclass__&lt;/span&gt;&lt;/code&gt; attribute is properly ignored.&lt;/p&gt;
&lt;div class="highlight-python notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# Metaclass syntax in Python3, illegal in Python2&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;X&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;metaclass&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;Y&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;pass&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="highlight-python notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# Metaclass syntax in Python2, no effect in Python3&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;X&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;__metaclass__&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Y&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;注解&lt;/p&gt;
&lt;p&gt;The way to make a use of a metaclass in a portable way, is to
create a based class that has it and then inherit from it. Sad,
isn’ it. Surely, the support for &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;__metaclass__&lt;/span&gt;&lt;/code&gt; could still
live.&lt;/p&gt;
&lt;div class="highlight-python notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# For Python2/3 compatible source, we create a base class that has the&lt;/span&gt;
&lt;span class="c1"&gt;# metaclass used and doesn&amp;#39;t require making a choice.&lt;/span&gt;

&lt;span class="n"&gt;CPythonNodeMetaClassBase&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;NodeCheckMetaClass&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;CPythonNodeMetaClassBase&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;object&lt;/span&gt;&lt;span class="p"&gt;,),&lt;/span&gt; &lt;span class="p"&gt;{})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;--dump-xml&lt;/span&gt;&lt;/code&gt; option works with Nuitka running under Python3.
This was not previously supported.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Python3 now also has compatible parameter errors and compatible
exception error messages.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Python3 has changed scope rules for list contractions (assignments
don’t affect outside values) and this is now respected as well.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Python3 has gained support for recursive programs and stand alone
extension modules, these are now both possible as well.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section id="optimization"&gt;
&lt;h2&gt;Optimization&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Avoid frame stack entries for functions that cannot raise exceptions,
i.e. where they would not be used.&lt;/p&gt;
&lt;p&gt;This avoids overhead for the very simple functions. And example of
this can be seen here:&lt;/p&gt;
&lt;div class="highlight-python notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;simple&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="mi"&gt;7&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Optimize &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;len&lt;/span&gt;&lt;/code&gt; built-in for non-constant, but known length values.&lt;/p&gt;
&lt;p&gt;An example can be seen here:&lt;/p&gt;
&lt;div class="highlight-python notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# The range isn&amp;#39;t constructed at compile time, but we still know its&lt;/span&gt;
&lt;span class="c1"&gt;# length.&lt;/span&gt;
&lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;10000000&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="c1"&gt;# The string isn&amp;#39;t constructed at compile time, but we still know its&lt;/span&gt;
&lt;span class="c1"&gt;# length.&lt;/span&gt;
&lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;*&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="mi"&gt;1000&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c1"&gt;# The tuple isn&amp;#39;t constructed, instead it&amp;#39;s known length is used, and&lt;/span&gt;
&lt;span class="c1"&gt;# side effects are maintained.&lt;/span&gt;
&lt;span class="nb"&gt;len&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt;&lt;span class="p"&gt;()))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;This new optimization applies to all kinds of container creations and
the &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;range&lt;/span&gt;&lt;/code&gt; built-in initially.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Optimize conditions for non-constant, but known truth values.&lt;/p&gt;
&lt;p&gt;At this time, known truth values of non-constants means &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;range&lt;/span&gt;&lt;/code&gt;
built-in calls with know size and container creations.&lt;/p&gt;
&lt;p&gt;An example can be seen here:&lt;/p&gt;
&lt;div class="highlight-python notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;,):&lt;/span&gt;
    &lt;span class="nb"&gt;print&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;In Branch&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;It’s clear, that the tuple will be true, we just need to maintain the
side effect, which we do.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Optimize &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;or&lt;/span&gt;&lt;/code&gt; and &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;and&lt;/span&gt;&lt;/code&gt; operators for known truth values.&lt;/p&gt;
&lt;p&gt;See above for what has known truth values currently. This will be
most useful to predict conditions that need not be evaluated at all
due to short circuit nature, and to avoid checking against constant
values. Previously this could not be optimized, but now it can:&lt;/p&gt;
&lt;div class="highlight-python notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# The access and call to &amp;quot;something()&amp;quot; cannot possibly happen&lt;/span&gt;
&lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="n"&gt;something&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

&lt;span class="c1"&gt;# Can be replaced with &amp;quot;something()&amp;quot;, as &amp;quot;1&amp;quot; is true. If it had a side&lt;/span&gt;
&lt;span class="c1"&gt;# effect, it would be maintained.&lt;/span&gt;
&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="n"&gt;something&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

&lt;span class="c1"&gt;# The access and call to &amp;quot;something()&amp;quot; cannot possibly happen, the value&lt;/span&gt;
&lt;span class="c1"&gt;# is already decided, it&amp;#39;s &amp;quot;1&amp;quot;.&lt;/span&gt;
&lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="ow"&gt;or&lt;/span&gt; &lt;span class="n"&gt;something&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

&lt;span class="c1"&gt;# Can be replaced with &amp;quot;something()&amp;quot;, as &amp;quot;0&amp;quot; is false. If it had a side&lt;/span&gt;
&lt;span class="c1"&gt;# effect, it would be maintained.&lt;/span&gt;
&lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="ow"&gt;or&lt;/span&gt; &lt;span class="n"&gt;something&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Optimize print arguments to become strings.&lt;/p&gt;
&lt;p&gt;The arguments to &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;print&lt;/span&gt;&lt;/code&gt; statements are now converted to strings at
compile time if possible.&lt;/p&gt;
&lt;div class="highlight-python notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nb"&gt;print&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;becomes:&lt;/p&gt;
&lt;div class="highlight-python notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nb"&gt;print&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;1&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Combine print arguments to single ones.&lt;/p&gt;
&lt;p&gt;When multiple strings are printed, these are now combined.&lt;/p&gt;
&lt;div class="highlight-python notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nb"&gt;print&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;1+1=&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;becomes:&lt;/p&gt;
&lt;div class="highlight-python notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nb"&gt;print&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;1+1= 2&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section id="organisational"&gt;
&lt;h2&gt;Organisational&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;Enhanced Python3 support, enabling support for most basic tests.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Check files with PyLint in deterministic (alphabetical) order.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section id="cleanups"&gt;
&lt;h2&gt;Cleanups&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;Frame stack entries are now part of the node tree instead of part of
the template for every function, generator, class or module.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;try&lt;/span&gt;&lt;/code&gt;/&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;except&lt;/span&gt;&lt;/code&gt;/&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;else&lt;/span&gt;&lt;/code&gt; has been re-formulated to use an
indicator variable visible in the node tree, that tells if a handler
has been executed or not.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Side effects are now a dedicated node, used in several optimization
to maintain the effect of an expression with known value.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section id="new-tests"&gt;
&lt;h2&gt;New Tests&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;Expanded and adapted basic tests to work for Python3 as well.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Added reference count tests for generator functions &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;throw&lt;/span&gt;&lt;/code&gt;,
&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;send&lt;/span&gt;&lt;/code&gt;, and &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;close&lt;/span&gt;&lt;/code&gt; methods.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Cover calling a function with &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;try&lt;/span&gt;&lt;/code&gt;/&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;except&lt;/span&gt;&lt;/code&gt; in an exception
handler twice. No test was previously doing that.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section id="summary"&gt;
&lt;h2&gt;Summary&lt;/h2&gt;
&lt;p&gt;This release offers enhanced compatibility with Python3, as well as the
solution to many structural problems. Calculating lengths of large
non-constant values at compile time, is technically a break through, as
is avoiding lengthy calculations. The frame guards as nodes is a huge
improvement, making that costly operational possible to be optimized
away.&lt;/p&gt;
&lt;p&gt;There still is more work ahead, before value propagation will be safe
enough to enable, but we are seeing the glimpse of it already. Not for
long, and looking at numbers will make sense.&lt;/p&gt;
&lt;/section&gt;
&lt;/section&gt;
</content>
    <link href="https://nuitka.net/posts/nuitka-release-0322.html" rel="alternate"/>
    <summary>This is to inform you about the new stable release of Nuitka. It is the extremely compatible Python compiler,
“download now”.</summary>
    <category term="compiler" label="compiler"/>
    <category term="Python" label="Python"/>
    <category term="Nuitka" label="Nuitka"/>
    <published>2012-05-13T13:17:00+00:00</published>
  </entry>
  <entry>
    <id>https://nuitka.net/posts/nikola-for-nuitka.html</id>
    <title>Nikola for nuitka.net</title>
    <updated>2012-05-26T13:06:00+00:00</updated>
    <author>
      <name>Kay Hayen</name>
    </author>
    <content type="html">&lt;section id="nikola-for-nuitka-net"&gt;

&lt;p&gt;Some time ago, I &lt;a class="reference external" href="/posts/static-site-generator.html"&gt;asked about static site generators&lt;/a&gt; and tried a few, but nothing was
as ReST friendly as I would like to. To me, ReST is to text publishing,
what Python is to programming.&lt;/p&gt;
&lt;p&gt;Well, the search has found a late hit. I had installed a work flow,
where I was using the XMLRPC interface, but it was some effort, and
somewhat limited.&lt;/p&gt;
&lt;p&gt;Then &lt;a class="reference external" href="http://ralsina.com.ar"&gt;Roberto Alsina&lt;/a&gt; announced &lt;a class="reference external" href="http://nikola.ralsina.com.ar"&gt;Nikola&lt;/a&gt; that was just what I wanted.&lt;/p&gt;
&lt;p&gt;I did migrate to it during the last days. Looking at the content in ReST
form, was a big ease, and I already found a bit of obsolete content, and
updated it. And the last release announcements, they now render somewhat
prettier.&lt;/p&gt;
&lt;p&gt;I am not using all the features yet, notable not using the image
galleries yet, and the download page is not yet generated again, and so
on. But this is a good base.&lt;/p&gt;
&lt;p&gt;And while I loved it, this was the result:&lt;/p&gt;
&lt;div class="highlight-default notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;apt&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;get&lt;/span&gt; &lt;span class="n"&gt;remove&lt;/span&gt; &lt;span class="n"&gt;wordpress&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
</content>
    <link href="https://nuitka.net/posts/nikola-for-nuitka.html" rel="alternate"/>
    <summary>Some time ago, I asked about static site generators and tried a few, but nothing was
as ReST friendly as I would like to. To me, ReST is to text publishing,
what Python is to programming.</summary>
    <category term="Python" label="Python"/>
    <category term="Nikola" label="Nikola"/>
    <published>2012-05-26T13:06:00+00:00</published>
  </entry>
  <entry>
    <id>https://nuitka.net/posts/nikola-speed-improvements.html</id>
    <title>Nikola Speed Improvements</title>
    <updated>2012-06-12T13:15:00+00:00</updated>
    <author>
      <name>Kay Hayen</name>
    </author>
    <content type="html">&lt;section id="nikola-speed-improvements"&gt;

&lt;p&gt;At end the end of May, I switched my website from a W3 Total Cache
enhanced wordpress installation to static generated with Nikola, and
this is what Google Webmaster tool says about it.&lt;/p&gt;
&lt;img alt="../_images/nikola-speed-improvements.png" src="../_images/nikola-speed-improvements.png" /&gt;
&lt;p&gt;The numbers are average time to download pages in milliseconds.&lt;/p&gt;
&lt;/section&gt;
</content>
    <link href="https://nuitka.net/posts/nikola-speed-improvements.html" rel="alternate"/>
    <summary>At end the end of May, I switched my website from a W3 Total Cache
enhanced wordpress installation to static generated with Nikola, and
this is what Google Webmaster tool says about it.</summary>
    <category term="Python" label="Python"/>
    <category term="Nikola" label="Nikola"/>
    <published>2012-06-12T13:15:00+00:00</published>
  </entry>
  <entry>
    <id>https://nuitka.net/posts/speedcenter-is-back.html</id>
    <title>Nuitka Speedcenter is back</title>
    <updated>2012-06-30T16:39:00+00:00</updated>
    <author>
      <name>Kay Hayen</name>
    </author>
    <content type="html">&lt;section id="nuitka-speedcenter-is-back"&gt;

&lt;p&gt;Once a long time ago, I was benchmarking Nuitka more often. Check &lt;a class="reference external" href="/pages/overview.html"&gt;“What
is Nuitka?”&lt;/a&gt; in case you don’t know what it
is.&lt;/p&gt;
&lt;section id="problem"&gt;
&lt;h2&gt;Problem&lt;/h2&gt;
&lt;p&gt;And I was considering the use of codespeed, and had some data online.
But ultimately, it got discontinued. This has 3 reasons:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Moved the website to a dedicated machine, which broke the previous
install.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Controlling which data is used for display was hard and not
satisfactory.&lt;/p&gt;
&lt;ol class="arabic"&gt;
&lt;li&gt;&lt;p&gt;For example, I didn’t want to have to commit and push, just to let
the benchmarks run.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;And I wanted to be able to re-run benchmarks with newer compiler,
even newer Python, but old Nuitka. Using g++ 4.6 over g++ 4.5
should not impact the data.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;It turned out to be a nightmare to migrate to newer codespeed
versions. I found myself starting from empty database - over and
over.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Many things were not supported.&lt;/p&gt;
&lt;p&gt;For example, I would want to collect all PyBench results, but only
publish those who are expressive. That seemed difficult to
achieve.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Benchmarks of Nuitka are not yet useful&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;&lt;p&gt;Nuitka was not yet doing type inference&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Most of the work was aimed at correctness, and effectively was
often degrading performance even if only temporary. Seeing it
wouldn’t have been too motivating.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section id="solution"&gt;
&lt;h2&gt;Solution&lt;/h2&gt;
&lt;p&gt;I have simply created a small wrapper:&lt;/p&gt;
&lt;ol class="arabic"&gt;
&lt;li&gt;&lt;p&gt;Small script to run benchmarks and collect data.&lt;/p&gt;
&lt;p&gt;It checks out Nuitka in all versions in a playground, and then runs
defined benchmarks, with valgrind, etc. taking exe sizes, etc.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Data is stored in local sqlite databases.&lt;/p&gt;
&lt;p&gt;I have a database per machine, i.e. a distributed repository, where I
collect information. That works for me, and will allow me to compare
different kinds of machines.&lt;/p&gt;
&lt;p&gt;The advantage is that I have no risk of data loss anymore, and no
issues and difficulty with poor interfaces to replace existing data.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Data is merged on one machine, and then pushed.&lt;/p&gt;
&lt;p&gt;That allows me to inspect the changes before publishing them. It
allows me to play with local commits, branches, with information that
will go away. I can then push when I choose to.&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;That integrates better with my work flow. It allows me to retro-fit
benchmarks results on the machine and to be tool independent.&lt;/p&gt;
&lt;p&gt;In principle, I could publish the data in other forms as well, and I
likely will. Making tables of e.g. PyBench results seems like one
application. Recently, I have worked with Nikola, and could also imagine
to integrate Codespeed graph functionality (which is apparently all I
want) to there.&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;Yours,&lt;/div&gt;
&lt;div class="line"&gt;Kay&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;/section&gt;
</content>
    <link href="https://nuitka.net/posts/speedcenter-is-back.html" rel="alternate"/>
    <summary>Once a long time ago, I was benchmarking Nuitka more often. Check “What
is Nuitka?” in case you don’t know what it
is.</summary>
    <category term="compiler" label="compiler"/>
    <category term="Nuitka" label="Nuitka"/>
    <category term="Nikola" label="Nikola"/>
    <category term="Python" label="Python"/>
    <category term="benchmark" label="benchmark"/>
    <published>2012-06-30T16:39:00+00:00</published>
  </entry>
  <entry>
    <id>https://nuitka.net/posts/nuitka-release-0323.html</id>
    <title>Nuitka Release 0.3.23</title>
    <updated>2012-06-30T23:40:00+00:00</updated>
    <author>
      <name>Kay Hayen</name>
    </author>
    <content type="html">&lt;section id="nuitka-release-0-3-23"&gt;

&lt;p&gt;This is to inform you about the new stable release of &lt;a class="reference external" href="https://nuitka.net"&gt;Nuitka&lt;/a&gt;. It is the extremely compatible Python compiler,
&lt;a class="reference external" href="/doc/download.html"&gt;“download now”&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;This release is the one that completes the Nuitka “sun rise phase”.&lt;/p&gt;
&lt;p&gt;All of Nuitka is now released under &lt;a class="reference external" href="http://www.apache.org/licenses/LICENSE-2.0"&gt;Apache License 2.0&lt;/a&gt; which is a very liberal
license, and compatible with basically all Free Software licenses there
are. It’s only asking to allow integration, of what you send back, and
patent grants for the code.&lt;/p&gt;
&lt;p&gt;In the first phase of Nuitka development, I wanted to keep control over
Nuitka, so it wouldn’t repeat mistakes of other projects. This is no
longer a concern for me, it’s not going to happen anymore.&lt;/p&gt;
&lt;p&gt;I would like to thank Debian Legal team, for originally bringing to my
attention, that this license will be better suited, than any copyright
assignment could be.&lt;/p&gt;
&lt;section id="bug-fixes"&gt;
&lt;h2&gt;Bug fixes&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;The compiled functions could not be used with &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;multiprocessing&lt;/span&gt;&lt;/code&gt; or
&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;copy.copy&lt;/span&gt;&lt;/code&gt;. Fixed in 0.3.22.1 already.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;In-place operations for slices with not both bounds specified crashed
the compiler. Fixed in 0.3.22.1 already.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Cyclic imports could trigger an endless loop, because module import
expressions became the parent of the imported module object. Fixed in
0.3.22.2 already.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Modules named &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;proc&lt;/span&gt;&lt;/code&gt; or &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;func&lt;/span&gt;&lt;/code&gt; could not be compiled to modules
or embedded due to a collision with identifiers of CPython2.7
includes. Fixed in 0.3.22.2 already.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section id="new-features"&gt;
&lt;h2&gt;New Features&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;The function copying fix also makes pickling of compiled functions
available. As it is the case for non-compiled functions in CPython,
no code objects are stored, only names of module level variables.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section id="organisational"&gt;
&lt;h2&gt;Organisational&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Using the Apache License 2.0 for all of Nuitka now.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Speedcenter has been re-activated, but is not yet having a lot of
benchmarks yet, subject to change.&lt;/p&gt;
&lt;div class="admonition-update admonition"&gt;
&lt;p class="admonition-title"&gt;Update&lt;/p&gt;
&lt;p&gt;We have given up on this version of speedcenter meanwhile, and
generate static pages with graphs instead. We can this still
speedcenter.&lt;/p&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section id="new-tests"&gt;
&lt;h2&gt;New Tests&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;Changed the “CPython26” tests to no longer disable the parts that
relied on copying of functions to work as that is now supported.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Extended in-place assignment tests to cover error cases of we had
issues with.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Extended compile library test to also try and compile the path where
&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;numpy&lt;/span&gt;&lt;/code&gt; lives. This is apparently another path, where Debian
installs some modules, and compiling this would have revealed issues
sooner.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section id="summary"&gt;
&lt;h2&gt;Summary&lt;/h2&gt;
&lt;p&gt;The release contains bug fixes, and the huge step of changing &lt;a class="reference external" href="http://www.apache.org/licenses/LICENSE-2.0"&gt;the
license&lt;/a&gt;. It is made in
preparation to &lt;a class="reference external" href="https://ep2012.europython.eu"&gt;PyCON EU&lt;/a&gt;.&lt;/p&gt;
&lt;/section&gt;
&lt;/section&gt;
</content>
    <link href="https://nuitka.net/posts/nuitka-release-0323.html" rel="alternate"/>
    <summary>This is to inform you about the new stable release of Nuitka. It is the extremely compatible Python compiler,
“download now”.</summary>
    <category term="compiler" label="compiler"/>
    <category term="Python" label="Python"/>
    <category term="Nuitka" label="Nuitka"/>
    <published>2012-06-30T23:40:00+00:00</published>
  </entry>
  <entry>
    <id>https://nuitka.net/posts/nuitka-and-debian-changes.html</id>
    <title>Nuitka and Debian changes</title>
    <updated>2012-07-05T14:52:00+00:00</updated>
    <author>
      <name>Kay Hayen</name>
    </author>
    <content type="html">&lt;section id="nuitka-and-debian-changes"&gt;

&lt;p&gt;Hello everybody,&lt;/p&gt;
&lt;p&gt;this is just a quick note to Nuitka users that are Debian users. For
Debian, the freeze has arrived. This is a time of great joy for me. I
love Debian so deeply, I believe I am now for at least 10 years on it,
of 15 years on Linux.&lt;/p&gt;
&lt;p&gt;As you may know, Nuitka has been in Debian for some time now. In
discussion with my great sponsor Yaroslav Halchenko, we needed to
consider if Nuitka is ready to be maintained in Debian Stable.&lt;/p&gt;
&lt;p&gt;And for that I have to admit, it is just not ready. You will be able to
download packages from the &lt;a class="reference external" href="/pages/download.html"&gt;Downloads&lt;/a&gt; and
install them. They will still be in Debian Unstable, but they won’t be
in Debian Testing and the next Debian Stable.&lt;/p&gt;
&lt;/section&gt;
</content>
    <link href="https://nuitka.net/posts/nuitka-and-debian-changes.html" rel="alternate"/>
    <summary>Hello everybody,</summary>
    <category term="Debian" label="Debian"/>
    <category term="Nuitka" label="Nuitka"/>
    <published>2012-07-05T14:52:00+00:00</published>
  </entry>
  <entry>
    <id>https://nuitka.net/posts/python-assert-quiz.html</id>
    <title>Python Assert Quiz</title>
    <updated>2012-07-15T17:07:00+00:00</updated>
    <author>
      <name>Kay Hayen</name>
    </author>
    <content type="html">&lt;section id="python-assert-quiz"&gt;

&lt;p&gt;At Europython conference, in my presentation, I talked about
re-formulations of Python into simpler Python. It is my intention to
turn this into a series of Python quiz questions that you will hopefully
enjoy.&lt;/p&gt;
&lt;div class="admonition-update admonition"&gt;
&lt;p class="admonition-title"&gt;Update&lt;/p&gt;
&lt;p&gt;Due to comments feedback, I made it more clear that “-O” affects of
course both cases, and due to work on getting the recent CPython2.7
test suite to work, I noticed, how the re-formulation for Quiz
Question 2 needed a version dependent solution.&lt;/p&gt;
&lt;p&gt;And I thought this one was easy. :-)&lt;/p&gt;
&lt;/div&gt;
&lt;section id="quiz-question-1"&gt;
&lt;h2&gt;Quiz Question 1&lt;/h2&gt;
&lt;p&gt;Say you have the following code:&lt;/p&gt;
&lt;div class="highlight-python notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;How can you achieve the same thing, without using the &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;assert&lt;/span&gt;&lt;/code&gt;
statement at all. The behavior is required to be absolutely the same.&lt;/p&gt;
&lt;p&gt;The answer is in the next paragraph, so stop reading if you want to find
out yourself.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="solution-1"&gt;
&lt;h2&gt;Solution 1&lt;/h2&gt;
&lt;p&gt;The correct answer is that assertions are the same as a raise exception
in a conditional statement.&lt;/p&gt;
&lt;div class="highlight-python notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;raise&lt;/span&gt; &lt;span class="ne"&gt;AssertionError&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;The thing where this makes a difference, is “-O”, which will discard
assertions, but I consider it rarely used. To be really compatible with
that, it should be:&lt;/p&gt;
&lt;div class="highlight-python notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;__debug__&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;raise&lt;/span&gt; &lt;span class="ne"&gt;AssertionError&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section id="quiz-question-2"&gt;
&lt;h2&gt;Quiz Question 2&lt;/h2&gt;
&lt;p&gt;But wait, there is slightly more to it. Say you have the following code:&lt;/p&gt;
&lt;div class="highlight-python notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;assert&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;arg&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;How can you achieve the same thing, without using the &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;assert&lt;/span&gt;&lt;/code&gt;
statement at all. The behavior is required to be absolutely the same.&lt;/p&gt;
&lt;p&gt;The answer is in the next paragraph, so stop reading if you want to find
out yourself.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="solution-2"&gt;
&lt;h2&gt;Solution 2&lt;/h2&gt;
&lt;p&gt;This is actually version dependent, due to recent optimizations of
CPython.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;For version 2.6 it is as follows:&lt;/p&gt;
&lt;p&gt;The extra value to &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;assert&lt;/span&gt;&lt;/code&gt;, simply becomes an extra value to
raise, which indicates, delayed creation of the &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;AssertionError&lt;/span&gt;&lt;/code&gt;
exception.&lt;/p&gt;
&lt;div class="highlight-python notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;raise&lt;/span&gt; &lt;span class="ne"&gt;AssertionError&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;arg&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;For version 2.7 and higher it is as follows:&lt;/p&gt;
&lt;p&gt;The extra value to &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;assert&lt;/span&gt;&lt;/code&gt;, simply becomes the argument to
creating the &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;AssertionError&lt;/span&gt;&lt;/code&gt; exception.&lt;/p&gt;
&lt;div class="highlight-python notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="k"&gt;raise&lt;/span&gt; &lt;span class="ne"&gt;AssertionError&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arg&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;So, even in the more complex case, you end up with a conditional
&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;raise&lt;/span&gt;&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The only thing where this makes a difference, is “-O”, which will
discard assertions, but I consider it rarely used. To be really
compatible with that, it should be:&lt;/p&gt;
&lt;blockquote&gt;
&lt;div&gt;&lt;div class="highlight-python notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;__debug__&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
   &lt;span class="k"&gt;raise&lt;/span&gt; &lt;span class="ne"&gt;AssertionError&lt;/span&gt; &lt;span class="o"&gt;....&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;&lt;/blockquote&gt;
&lt;p&gt;Surprised? Well, yes, there really is nothing to &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;assert&lt;/span&gt;&lt;/code&gt; statements.
I am using this for my &lt;a class="reference external" href="/pages/overview.html"&gt;Python compiler Nuitka&lt;/a&gt;
which benefits from having not to deal with &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;assert&lt;/span&gt;&lt;/code&gt; as anything
special at all. See also the &lt;a class="reference external" href="/doc/developer-manual.html#the-assert-statement"&gt;respective section in the Developer Manual&lt;/a&gt; which explains this
and other things.&lt;/p&gt;
&lt;/section&gt;
&lt;/section&gt;
</content>
    <link href="https://nuitka.net/posts/python-assert-quiz.html" rel="alternate"/>
    <summary>At Europython conference, in my presentation, I talked about
re-formulations of Python into simpler Python. It is my intention to
turn this into a series of Python quiz questions that you will hopefully
enjoy.</summary>
    <category term="Python" label="Python"/>
    <category term="Nuitka" label="Nuitka"/>
    <category term="quiz" label="quiz"/>
    <published>2012-07-15T17:07:00+00:00</published>
  </entry>
  <entry>
    <id>https://nuitka.net/posts/python-3-wonders-barry-bdfl.html</id>
    <title>Python 3 wonders - Barry BDFL</title>
    <updated>2012-07-23T06:56:41+00:00</updated>
    <author>
      <name>Kay Hayen</name>
    </author>
    <content type="html">&lt;section id="python-3-wonders-barry-bdfl"&gt;

&lt;p&gt;While writing &lt;a class="reference external" href="/pages/overview.html"&gt;Nuitka&lt;/a&gt; I get to see an absurd
amount of CPython code. For a while now, it’s also CPython3.2 that I
look at. Checking out &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;__future__&lt;/span&gt;&lt;/code&gt; handling, I was surprised the other
day though, this really works:&lt;/p&gt;
&lt;div class="highlight-python notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;# Python 3.2.3 (default, Jun 25 2012, 23:10:56)&lt;/span&gt;
&lt;span class="c1"&gt;# [GCC 4.7.1] on linux2&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;__future__&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;barry_as_FLUFL&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;
&lt;span class="kc"&gt;True&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;
  &lt;span class="n"&gt;File&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;&amp;lt;stdin&amp;gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
    &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;
       &lt;span class="o"&gt;^&lt;/span&gt;
&lt;span class="ne"&gt;SyntaxError&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;invalid&lt;/span&gt; &lt;span class="n"&gt;syntax&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;It’s new in CPython3, and this the code that makes it possible, from the
Python parser:&lt;/p&gt;
&lt;div class="highlight-c++ notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;==&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;NOTEQUAL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ps&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;p_flags&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;CO_FUTURE_BARRY_AS_BDFL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                    &lt;/span&gt;&lt;span class="n"&gt;strcmp&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;!=&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;PyObject_FREE&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;err_ret&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;error&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;E_SYNTAX&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;ps&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;p_flags&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;CO_FUTURE_BARRY_AS_BDFL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                    &lt;/span&gt;&lt;span class="n"&gt;strcmp&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&amp;lt;&amp;gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;PyObject_FREE&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;str&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;err_ret&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;text&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;with Barry as BDFL, use &amp;#39;&amp;lt;&amp;gt;&amp;#39; &amp;quot;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;                        &lt;/span&gt;&lt;span class="s"&gt;&amp;quot;instead of &amp;#39;!=&amp;#39;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="n"&gt;err_ret&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;error&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="w"&gt; &lt;/span&gt;&lt;span class="n"&gt;E_SYNTAX&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;        &lt;/span&gt;&lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="w"&gt;    &lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="w"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Now who would think bad of that, would you? The fun aspect is, that
Nuitka will easily supports it. By re-using the Python parser, it works
out of the box, I only needed to add the flag value.&lt;/p&gt;
&lt;p&gt;For fun, I tried to add a test that confirms - and then notice:&lt;/p&gt;
&lt;blockquote&gt;
&lt;div&gt;&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;It doesn’t really work for CPython3.2 already.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The flag is only used for &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;eval&lt;/span&gt;&lt;/code&gt; and &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;exec&lt;/span&gt;&lt;/code&gt; and not on the
same level, so it’s only inherited.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;And “2to3” kindly removes that flag silently. It probably should
raise an error.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;&lt;/blockquote&gt;
&lt;p&gt;So yeah, oddities in Python3!&lt;/p&gt;
&lt;/section&gt;
</content>
    <link href="https://nuitka.net/posts/python-3-wonders-barry-bdfl.html" rel="alternate"/>
    <summary>While writing Nuitka I get to see an absurd
amount of CPython code. For a while now, it’s also CPython3.2 that I
look at. Checking out __future__ handling, I was surprised the other
day though, this really works:</summary>
    <category term="Python" label="Python"/>
    <category term="Nuitka" label="Nuitka"/>
    <published>2012-07-23T06:56:41+00:00</published>
  </entry>
  <entry>
    <id>https://nuitka.net/posts/python-3-wonders-breaking-str.html</id>
    <title>Python 3 wonders - Breaking str</title>
    <updated>2012-08-15T21:42:28+00:00</updated>
    <author>
      <name>Kay Hayen</name>
    </author>
    <content type="html">&lt;section id="python-3-wonders-breaking-str"&gt;

&lt;p&gt;That just killed some hope inside of me, breaking code that uses &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;str&lt;/span&gt;&lt;/code&gt;
ought to be forbidden.&lt;/p&gt;
&lt;div class="admonition-update admonition"&gt;
&lt;p class="admonition-title"&gt;Update&lt;/p&gt;
&lt;p&gt;Turns out, this only a bug, and not intentional. And the bug is only
in the doc string, so it’s being fixed, and there is no inconsistency
then any more.&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;Python 3:&lt;/p&gt;
&lt;div class="highlight-default notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;Python&lt;/span&gt; &lt;span class="mf"&gt;3.2.3&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;default&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Jun&lt;/span&gt; &lt;span class="mi"&gt;25&lt;/span&gt; &lt;span class="mi"&gt;2012&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;23&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;56&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;GCC&lt;/span&gt; &lt;span class="mf"&gt;4.7.1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;on&lt;/span&gt; &lt;span class="n"&gt;linux2&lt;/span&gt;
&lt;span class="n"&gt;Type&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;help&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;copyright&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;credits&amp;quot;&lt;/span&gt; &lt;span class="ow"&gt;or&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;license&amp;quot;&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;more&lt;/span&gt; &lt;span class="n"&gt;information&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;print&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="vm"&gt;__doc__&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="p"&gt;[,&lt;/span&gt; &lt;span class="n"&gt;encoding&lt;/span&gt;&lt;span class="p"&gt;[,&lt;/span&gt; &lt;span class="n"&gt;errors&lt;/span&gt;&lt;span class="p"&gt;]])&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;str&lt;/span&gt;

&lt;span class="n"&gt;Create&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="nb"&gt;object&lt;/span&gt; &lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;the&lt;/span&gt; &lt;span class="n"&gt;given&lt;/span&gt; &lt;span class="n"&gt;encoded&lt;/span&gt; &lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;
&lt;span class="n"&gt;encoding&lt;/span&gt; &lt;span class="n"&gt;defaults&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;current&lt;/span&gt; &lt;span class="n"&gt;default&lt;/span&gt; &lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;encoding&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;
&lt;span class="n"&gt;errors&lt;/span&gt; &lt;span class="n"&gt;can&lt;/span&gt; &lt;span class="n"&gt;be&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;strict&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;replace&amp;#39;&lt;/span&gt; &lt;span class="ow"&gt;or&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;ignore&amp;#39;&lt;/span&gt; &lt;span class="ow"&gt;and&lt;/span&gt; &lt;span class="n"&gt;defaults&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;strict&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;a&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;Traceback&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;most&lt;/span&gt; &lt;span class="n"&gt;recent&lt;/span&gt; &lt;span class="n"&gt;call&lt;/span&gt; &lt;span class="n"&gt;last&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
  &lt;span class="n"&gt;File&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;&amp;lt;stdin&amp;gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;line&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;module&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="ne"&gt;TypeError&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;string&amp;#39;&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="n"&gt;an&lt;/span&gt; &lt;span class="n"&gt;invalid&lt;/span&gt; &lt;span class="n"&gt;keyword&lt;/span&gt; &lt;span class="n"&gt;argument&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;this&lt;/span&gt; &lt;span class="n"&gt;function&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Python 2:&lt;/p&gt;
&lt;div class="highlight-default notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;Python&lt;/span&gt; &lt;span class="mf"&gt;2.7.3&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;default&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Jul&lt;/span&gt; &lt;span class="mi"&gt;13&lt;/span&gt; &lt;span class="mi"&gt;2012&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;17&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;48&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;29&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;GCC&lt;/span&gt; &lt;span class="mf"&gt;4.7.1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;on&lt;/span&gt; &lt;span class="n"&gt;linux2&lt;/span&gt;
&lt;span class="n"&gt;Type&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;help&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;copyright&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;credits&amp;quot;&lt;/span&gt; &lt;span class="ow"&gt;or&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;license&amp;quot;&lt;/span&gt; &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;more&lt;/span&gt; &lt;span class="n"&gt;information&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;print&lt;/span&gt; &lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="vm"&gt;__doc__&lt;/span&gt;
&lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;object&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;string&lt;/span&gt;

&lt;span class="n"&gt;Return&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;nice&lt;/span&gt; &lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;representation&lt;/span&gt; &lt;span class="n"&gt;of&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="nb"&gt;object&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;
&lt;span class="n"&gt;If&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;argument&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="n"&gt;string&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;value&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="n"&gt;the&lt;/span&gt; &lt;span class="n"&gt;same&lt;/span&gt; &lt;span class="nb"&gt;object&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;
&lt;span class="o"&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="nb"&gt;str&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="nb"&gt;object&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;a&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="s1"&gt;&amp;#39;a&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;I do understand that it’s in fact just the old &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;unicode&lt;/span&gt;&lt;/code&gt; built-in. In
fact, I made it work like that for Nuitka just now. But there is a
difference, for Python2, it was well behaved.&lt;/p&gt;
&lt;p&gt;Python 2:&lt;/p&gt;
&lt;div class="highlight-default notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="nb"&gt;print&lt;/span&gt; &lt;span class="n"&gt;unicode&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="vm"&gt;__doc__&lt;/span&gt;
&lt;span class="go"&gt;unicode(string [, encoding[, errors]]) -&amp;gt; object&lt;/span&gt;

&lt;span class="go"&gt;Create a new Unicode object from the given encoded string.&lt;/span&gt;
&lt;span class="go"&gt;encoding defaults to the current default string encoding.&lt;/span&gt;
&lt;span class="go"&gt;errors can be &amp;#39;strict&amp;#39;, &amp;#39;replace&amp;#39; or &amp;#39;ignore&amp;#39; and defaults to &amp;#39;strict&amp;#39;.&lt;/span&gt;
&lt;span class="gp"&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class="n"&gt;unicode&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;a&amp;quot;&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="go"&gt;u&amp;#39;a&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Is Python3 supposed to be more clean or what? I think it is not
happening.&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;Yours,&lt;/div&gt;
&lt;div class="line"&gt;Kay Hayen&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
</content>
    <link href="https://nuitka.net/posts/python-3-wonders-breaking-str.html" rel="alternate"/>
    <summary>That just killed some hope inside of me, breaking code that uses str
ought to be forbidden.</summary>
    <category term="Python" label="Python"/>
    <published>2012-08-15T21:42:28+00:00</published>
  </entry>
  <entry>
    <id>https://nuitka.net/posts/nuitka-release-0324.html</id>
    <title>Nuitka Release 0.3.24</title>
    <updated>2012-08-18T21:30:00+00:00</updated>
    <author>
      <name>Kay Hayen</name>
    </author>
    <content type="html">&lt;section id="nuitka-release-0-3-24"&gt;

&lt;p&gt;This is to inform you about the new stable release of &lt;a class="reference external" href="https://nuitka.net"&gt;Nuitka&lt;/a&gt;. It is the extremely compatible Python compiler,
&lt;a class="reference external" href="/doc/download.html"&gt;“download now”&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;This release contains progress on many fronts, except performance.&lt;/p&gt;
&lt;p&gt;The extended coverage from running the CPython 2.7 and CPython 3.2
(partially) test suites shows in a couple of bug fixes and general
improvements in compatibility.&lt;/p&gt;
&lt;p&gt;Then there is a promised new feature that allows to compile whole
packages.&lt;/p&gt;
&lt;p&gt;Also there is more Python3 compatibility, the CPython 3.2 test suite now
succeeds up to “test_builtin.py”, where it finds that &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;str&lt;/span&gt;&lt;/code&gt; doesn’t
support the new parameters it has gained, future releases will improve
on this.&lt;/p&gt;
&lt;p&gt;And then of course, more re-formulation work, in this case, class
definitions are now mere simple functions. This and later function
references, is the important and only progress towards type inference.&lt;/p&gt;
&lt;section id="bug-fixes"&gt;
&lt;h2&gt;Bug fixes&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;The compiled method type can now be used with &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;copy&lt;/span&gt;&lt;/code&gt; module. That
means, instances with methods can now be copied too. Fixed in
0.3.23.1 already.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;assert&lt;/span&gt;&lt;/code&gt; statement as of Python2.7 creates the
&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;AssertionError&lt;/span&gt;&lt;/code&gt; object from a given value immediately, instead of
delayed as it was with Python2.6. This makes a difference for the
form with 2 arguments, and if the value is a tuple. Fixed in 0.3.23.1
already.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Sets written like this didn’t work unless they were predicted at
compile time:&lt;/p&gt;
&lt;div class="highlight-python notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;value&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;This apparently rarely used Python2.7 syntax didn’t have code
generation yet and crashed the compiler. Fixed in 0.3.23.1 already.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;For Python2, the default encoding for source files is &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;ascii&lt;/span&gt;&lt;/code&gt;, and
it is now enforced by Nuitka as well, with the same &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;SyntaxError&lt;/span&gt;&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Corner cases of &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;exec&lt;/span&gt;&lt;/code&gt; statements with nested functions now give
proper &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;SyntaxError&lt;/span&gt;&lt;/code&gt; exceptions under Python2.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;exec&lt;/span&gt;&lt;/code&gt; statement with a tuple of length 1 as argument, now also
gives a &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;TypeError&lt;/span&gt;&lt;/code&gt; exception under Python2.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;For Python2, the &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;del&lt;/span&gt;&lt;/code&gt; of a closure variable is a &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;SyntaxError&lt;/span&gt;&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section id="new-features"&gt;
&lt;h2&gt;New Features&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;Added support creating compiled packages. If you give Nuitka a
directory with an “__init__.py” file, it will compile that package
into a “.so” file. Adding the package contents with &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;--recurse-dir&lt;/span&gt;&lt;/code&gt;
allows to compile complete packages now. Later there will be a
cleaner interface likely, where the later is automatic.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Added support for providing directories as main programs. It’s OK if
they contain a “__main__.py” file, then it’s used instead, otherwise
give compatible error message.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Added support for optimizing the &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;super&lt;/span&gt;&lt;/code&gt; built-in. It was already
working correctly, but not optimized on CPython2. But for CPython3,
the variant without any arguments required dedicated code.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Added support for optimizing the &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;unicode&lt;/span&gt;&lt;/code&gt; built-in under Python2.
It was already working, but will become the basis for the &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;str&lt;/span&gt;&lt;/code&gt;
built-in of Python3 in future releases.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;For Python3, lots of compatibility work has been done. The Unicode
issues appear to be ironed out now. The &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;del&lt;/span&gt;&lt;/code&gt; of closure variables
is allowed and supported now. Built-ins like &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;ord&lt;/span&gt;&lt;/code&gt; and &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;chr&lt;/span&gt;&lt;/code&gt; work
more correctly and attributes are now interned strings, so that
monkey patching classes works.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section id="organisational"&gt;
&lt;h2&gt;Organisational&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Migrated “bin/benchmark.sh” to Python as “misc/run-valgrind.py” and
made it a bit more portable that way. Prefers “/var/tmp” if it exists
and creates temporary files in a secure manner. Triggered by the
Debian “insecure temp file” bug.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Migrated “bin/make-dependency-graph.sh” to Python as
“misc/make-dependency-graph.py” and made a more portable and powerful
that way.&lt;/p&gt;
&lt;p&gt;The filtering is done a more robust way. Also it creates temporary
files in a secure manner, also triggered by the Debian “insecure temp
file” bug.&lt;/p&gt;
&lt;p&gt;And it creates SVG files and no longer PostScript as the first one is
more easily rendered these days.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Removed the “misc/gist” git sub-module, which was previously used by
“misc/make-doc.py” to generate HTML from &lt;a class="reference external" href="https://nuitka.net/doc/user-manual.html"&gt;User Manual&lt;/a&gt; and &lt;a class="reference external" href="https://nuitka.net/doc/developer-manual.html"&gt;Developer Manual&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;These are now done with Nikola, which is much better at it and it
integrates with the web site.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Lots of formatting improvements to the change log, and manuals:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;Marking identifiers with better suited ReStructured Text markup.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Added links to the bug tracker all Issues.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Unified wordings, quotation, across the documents.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section id="cleanups"&gt;
&lt;h2&gt;Cleanups&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;The creation of the class dictionaries is now done with normal
function bodies, that only needed to learn how to throw an exception
when directly called, instead of returning &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;NULL&lt;/span&gt;&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Also the assignment of &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;__module__&lt;/span&gt;&lt;/code&gt; and &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;__doc__&lt;/span&gt;&lt;/code&gt; in these has
become visible in the node tree, allowing their proper optimization.&lt;/p&gt;
&lt;p&gt;These re-formulation changes allowed to remove all sorts of special
treatment of &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;class&lt;/span&gt;&lt;/code&gt; code in the code generation phase, making
things a lot simpler.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;There was still a declaration of &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;PRINT_ITEMS&lt;/span&gt;&lt;/code&gt; and uses of it, but
no definition of it.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Code generation for “main” module and “other” modules are now merged,
and no longer special.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The use of raw strings was found unnecessary and potentially still
buggy and has been removed. The dependence on C++11 is getting less
and less.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section id="new-tests"&gt;
&lt;h2&gt;New Tests&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;Updated CPython2.6 test suite “tests/CPython26” to 2.6.8, adding
tests for recent bug fixes in CPython. No changes to Nuitka were
needed in order to pass, which is always good news.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Added CPython2.7 test suite as “tests/CPython27” from 2.7.3, making
it public for the first time. Previously a private copy of some age,
with many no longer needed changes had been used by me. Now it is up
to par with what was done before for “tests/CPython26”, so this
pending action is finally done.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Added test to cover Python2 syntax error of having a function with
closure variables nested inside a function that is an overflow
function.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Added test “BuiltinSuper” to cover &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;super&lt;/span&gt;&lt;/code&gt; usage details.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Added test to cover &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;del&lt;/span&gt;&lt;/code&gt; on nested scope as syntax error.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Added test to cover &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;exec&lt;/span&gt;&lt;/code&gt; with a tuple argument of length 1.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Added test to cover &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;barry_as_FLUFL&lt;/span&gt;&lt;/code&gt; future import to work.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Removed “Unicode” from known error cases for CPython3.2, it’s now
working.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section id="summary"&gt;
&lt;h2&gt;Summary&lt;/h2&gt;
&lt;p&gt;This release brought forward the most important remaining re-formulation
changes needed for Nuitka. Removing class bodies, makes optimization yet
again simpler. Still, making function references, so they can be copied,
is missing for value propagation to progress.&lt;/p&gt;
&lt;p&gt;Generally, as usual, a focus has been laid on correctness. This is also
the first time, I am release with a known bug though, one which I
believe now, may be the root cause of the mercurial tests not yet
passing.&lt;/p&gt;
&lt;p&gt;The solution will be involved and take a bit of time. It will be about
“compiled frames” and be a (invasive) solution. It likely will make
Nuitka faster too. But this release includes lots of tiny improvements,
for Python3 and also for Python2. So I wanted to get this out now.&lt;/p&gt;
&lt;p&gt;As usual, please check it out, and let me know how you fare.&lt;/p&gt;
&lt;/section&gt;
&lt;/section&gt;
</content>
    <link href="https://nuitka.net/posts/nuitka-release-0324.html" rel="alternate"/>
    <summary>This is to inform you about the new stable release of Nuitka. It is the extremely compatible Python compiler,
“download now”.</summary>
    <category term="compiler" label="compiler"/>
    <category term="Python" label="Python"/>
    <category term="Nuitka" label="Nuitka"/>
    <published>2012-08-18T21:30:00+00:00</published>
  </entry>
  <entry>
    <id>https://nuitka.net/posts/letting-go-of-c11.html</id>
    <title>Letting go of C++11</title>
    <updated>2012-10-27T08:59:07+00:00</updated>
    <author>
      <name>Kay Hayen</name>
    </author>
    <content type="html">&lt;p&gt;How Nuitka came to use C++11 and then stop it.&lt;/p&gt;
&lt;section id="letting-go-of-c-11"&gt;

&lt;p&gt;This post is about Nuitka the Python compiler started out using C++0x
which is now C++11, and then chose to stop it.&lt;/p&gt;
&lt;section id="in-the-beginning"&gt;
&lt;h2&gt;In the Beginning&lt;/h2&gt;
&lt;p&gt;Very early on, when I considered how to generate code from the node
tree, in a way, that mistakes should practically be impossible to make,
I made the fundamental decision, that every Python expression, which
produces temporary variables, should become an expression in the
generated code too.&lt;/p&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;注解&lt;/p&gt;
&lt;p&gt;That is my choice, I think it keeps code generation more simple, and
easier to understand. There may come a separate post about how that
played out.&lt;/p&gt;
&lt;/div&gt;
&lt;p&gt;That decision meant some trouble. Certain things were not easy, but
generally, it was achievable for g++ relatively quickly, and then lots
of helper functions would be needed. Think of &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;MAKE_TUPLE&lt;/span&gt;&lt;/code&gt; and
&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;MAKE_DICT&lt;/span&gt;&lt;/code&gt;, but also other stuff needed that. Calling a Python
built-in with variable number of parameters e.g. could be implemented
that way easily.&lt;/p&gt;
&lt;p&gt;Other nice things were &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;enum&lt;/span&gt;&lt;/code&gt; classes, and generally good stuff. It
was really quick to get Nuitka code generation off the ground this way.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="reality-strikes"&gt;
&lt;h2&gt;Reality Strikes&lt;/h2&gt;
&lt;p&gt;But then, as time went on, I found that the order of evaluation was
becoming an issue. It became apparent that for more and more things, I
needed to reverse it, so it works. Porting to ARM, it then became clear,
that it needs to be the other way around for that platform. And checking
out clang, which is also a C++11 compiler, I noticed, this one yet uses
a different one.&lt;/p&gt;
&lt;p&gt;So, for normal functions, I found a solution that involves the
pre-processor to reverse or not, &lt;em&gt;both&lt;/em&gt; function definition and call
sites, and then it is already correct.&lt;/p&gt;
&lt;p&gt;This of course, doesn’t work for C++11 variadic functions. So, there
came a point, where I had to realize, that each of its uses was more or
less causing evaluation order bugs. So that most of their uses were
already removed. And so I basically knew they couldn’t stay that way.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="other-features"&gt;
&lt;h2&gt;Other Features&lt;/h2&gt;
&lt;p&gt;Also, things I initially assumed, e.g. that lambda functions of C++11
may prove useful, or even “auto”, didn’t turn out to be true. There
seemingly is a wealth of new features, besides variadic templates that I
didn’t see how Nuitka would benefit from it at all.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="new-wishes"&gt;
&lt;h2&gt;New Wishes&lt;/h2&gt;
&lt;p&gt;Then, at Europython, I realized, that Android is still stuck with
g++-4.4 and as such, that an important target platform will be
unavailable to me. This platform will become even more important, as I
intend to buy an device now.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="biting-it"&gt;
&lt;h2&gt;Biting it&lt;/h2&gt;
&lt;p&gt;So what I did, was to remove all variadic functions and instead generate
code for them as necessary. I just need to trace the used argument
counts, and then provide those, simple enough.&lt;/p&gt;
&lt;p&gt;Also, other things like deleted copy constructors, and so on, I had to
give up on these a bit.&lt;/p&gt;
&lt;p&gt;This change was probably suited to remove subtle evaluation order
problems, although I don’t recall seeing them.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="the-present"&gt;
&lt;h2&gt;The Present&lt;/h2&gt;
&lt;p&gt;The current stable release still requires C++11, but the next release
will work on g++-4.4 and compiles fine with MSVC from Visual Studio
2008, although at this time, there is still the issue of generators not
working yet, but I believe that ought to be solvable.&lt;/p&gt;
&lt;p&gt;The new requirement is only C++03, which means, there is a good chance
that supporting Android will become feasible. I know there is interest
from App developers, because there, even the relatively unimportant 2x
speedup, that Nuitka might give for some code, may matter.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="conclusion"&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;So that is a detour, I have taken, expanding the base of Nuitka even
further. I felt, this was important enough to write down the history
part of it.&lt;/p&gt;
&lt;/section&gt;
&lt;/section&gt;
</content>
    <link href="https://nuitka.net/posts/letting-go-of-c11.html" rel="alternate"/>
    <summary>How Nuitka came to use C++11 and then stop it.</summary>
    <category term="Nuitka" label="Nuitka"/>
    <category term="compiler" label="compiler"/>
    <category term="Python" label="Python"/>
    <category term="Windows" label="Windows"/>
    <category term="Android" label="Android"/>
    <published>2012-10-27T08:59:07+00:00</published>
  </entry>
  <entry>
    <id>https://nuitka.net/posts/nuitka-release-0325.html</id>
    <title>Nuitka Release 0.3.25</title>
    <updated>2012-11-11T16:29:00+00:00</updated>
    <author>
      <name>Kay Hayen</name>
    </author>
    <content type="html">&lt;section id="nuitka-release-0-3-25"&gt;

&lt;p&gt;This is to inform you about the new stable release of &lt;a class="reference external" href="https://nuitka.net"&gt;Nuitka&lt;/a&gt;. It is the extremely compatible Python compiler,
&lt;a class="reference external" href="/doc/download.html"&gt;“download now”&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;This release brings about changes on all fronts, bug fixes, new
features. Also very importantly Nuitka no longer uses C++11 for its
code, but mere C++03. There is new re-formulation work, and re-factoring
of functions.&lt;/p&gt;
&lt;p&gt;But the most important part is this: Mercurial unit tests are working.
Nearly. With the usual disclaimer of me being wrong, all remaining
errors are errors of the test, or minor things. Hope is that these unit
tests can be added as release tests to Nuitka. And once that is done,
the next big Python application can come.&lt;/p&gt;
&lt;section id="bug-fixes"&gt;
&lt;h2&gt;Bug fixes&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Local variables were released when an exception was raised that
escaped the local function. They should only be released, after
another exception was raised somewhere.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Identifiers of nested tuples and lists could collide.&lt;/p&gt;
&lt;div class="highlight-python notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,),&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Both tuples had the same name previously, not the end of the tuple is
marked too. Fixed in 0.3.24.1 already.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;__name__&lt;/span&gt;&lt;/code&gt; when used read-only in modules in packages was
optimized to a string value that didn’t contain the package name.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Exceptions set when entering compiled functions were unset at
function exit.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section id="new-features"&gt;
&lt;h2&gt;New Features&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Compiled frames support. Before, Nuitka was creating frames with the
standard CPython C/API functions, and tried its best to cache them.
This involved some difficulties, but as it turns out, it is actually
possible to instead provide a compatible type of our own, that we
have full control over.&lt;/p&gt;
&lt;p&gt;This will become the base of enhanced compatibility. Keeping
references to local variables attached to exception tracebacks is
something we may be able to solve now.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Enhanced Python3 support, added support for &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;nonlocal&lt;/span&gt;&lt;/code&gt; declarations
and many small corrections for it.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Writable &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;__defaults__&lt;/span&gt;&lt;/code&gt; attribute for compiled functions, actually
changes the default value used at call time. Not supported is
changing the amount of default parameters.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section id="cleanups"&gt;
&lt;h2&gt;Cleanups&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;Keep the functions along with the module and added “FunctionRef” node
kind to point to them.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Reformulated &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;or&lt;/span&gt;&lt;/code&gt; and &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;and&lt;/span&gt;&lt;/code&gt; operators with the conditional
expression construct which makes the “short-circuit” branch.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Access &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;self&lt;/span&gt;&lt;/code&gt; in methods from the compiled function object instead
of pointer to context object, making it possible to access the
function object.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Removed “OverflowCheck” module and its usage, avoids one useless scan
per function to determine the need for “locals dictionary”.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Make “compileTree” of “MainControl” module to only do what the name
says and moved the rest out, making the top level control clearer.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Don’t export module entry points when building executable and not
modules. These exports cause MinGW and MSVC compilers to create
export libraries.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section id="optimization"&gt;
&lt;h2&gt;Optimization&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;More efficient code for conditional expressions in conditions:&lt;/p&gt;
&lt;div class="highlight-python notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;b&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="o"&gt;...&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;See above, this code is now the typical pattern for each &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;or&lt;/span&gt;&lt;/code&gt; and
&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;and&lt;/span&gt;&lt;/code&gt;, so this was much needed now.&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section id="organisational"&gt;
&lt;h2&gt;Organisational&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;The remaining uses of C++11 have been removed. Code generated with
Nuitka and complementary C++ code now compile with standard C++03
compilers. This lowers the Nuitka requirements and enables at least
g++ 4.4 to work with Nuitka.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The usages of the GNU extension operation &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;a&lt;/span&gt; &lt;span class="pre"&gt;?:&lt;/span&gt; &lt;span class="pre"&gt;b&lt;/span&gt;&lt;/code&gt; have replaced
with standard C++ constructs. This is needed to support MSVC which
doesn’t have this.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Added examples for the typical use cases to the &lt;a class="reference external" href="https://nuitka.net/doc/user-manual.html"&gt;User Manual&lt;/a&gt;.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;The “compare_with_cpython” script has gained an option to immediately
remove the Nuitka outputs (build directory and binary) if successful.
Also the temporary files are now put under “/var/tmp” if available.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Debian package improvements, registering with &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;doc-base&lt;/span&gt;&lt;/code&gt; the &lt;a class="reference external" href="https://nuitka.net/doc/user-manual.html"&gt;User
Manual&lt;/a&gt; so it is easier
to discover. Also suggest &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;mingw32&lt;/span&gt;&lt;/code&gt; package which provides the
cross compiler to Windows.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Partial support for MSVC (Visual Studio 2008 to be exact, the version
that works with CPython2.6 and CPython2.7).&lt;/p&gt;
&lt;p&gt;All basic tests that do not use generators are working now, but those
will currently cause crashes.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Renamed the &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;--g++-only&lt;/span&gt;&lt;/code&gt; option to &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;--c++-only&lt;/span&gt;&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The old name is no longer correct after clang and MSVC have gained
support, and it could be misunderstood to influence compiler
selection, rather than causing the C++ source code to not be updated,
so manual changes will the used.&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Catch exceptions for &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;continue&lt;/span&gt;&lt;/code&gt;, &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;break&lt;/span&gt;&lt;/code&gt;, and &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;return&lt;/span&gt;&lt;/code&gt; only
where needed for &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;try&lt;/span&gt;&lt;/code&gt;/&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;finally&lt;/span&gt;&lt;/code&gt; and loop constructs.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section id="new-tests"&gt;
&lt;h2&gt;New Tests&lt;/h2&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;Added CPython3.2 test suite as “tests/CPython32” from 3.2.3 and run
it with CPython2.7 to check that Nuitka gives compatible error
messages. It is not expected to pass yet on Python3.2, but work will
be done towards this goal.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Make CPython2.7 test suite runner also execute the generated
“doctest” modules.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Enabled tests for default parameters and their reference counts.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section id="summary"&gt;
&lt;h2&gt;Summary&lt;/h2&gt;
&lt;p&gt;This release marks an important point. The compiled frames are exciting
new technology, that will allow even better integration with CPython,
while improving speed. Lowering the requirements to C++03 means, we will
become usable on Android and with MSVC, which will make adoption of
Nuitka on Windows easier for many.&lt;/p&gt;
&lt;p&gt;Structurally the outstanding part is the function as references cleanup.
This was a blocker for value propagation, because now functions
references can be copied, whereas previously this was duplicating the
whole function body, which didn’t work, and wasn’t acceptable. Now, work
can resume in this domain.&lt;/p&gt;
&lt;p&gt;Also very exciting when it comes to optimization is the remove of
special code for &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;or&lt;/span&gt;&lt;/code&gt; and &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;and&lt;/span&gt;&lt;/code&gt; operators, as these are now only
mere conditional expressions. Again, this will make value propagation
easier with two special cases less.&lt;/p&gt;
&lt;p&gt;And then of course, with Mercurial unit tests running compiled with
Nuitka, an important milestone has been hit.&lt;/p&gt;
&lt;p&gt;For a while now, the focus will be on completing Python3 support, XML
based optimization regression tests, benchmarks, and other open ends.
Once that is done, and more certainty about Mercurial tests support, I
may call it a 0.4 and start with local type inference for actual speed
gains.&lt;/p&gt;
&lt;/section&gt;
&lt;/section&gt;
</content>
    <link href="https://nuitka.net/posts/nuitka-release-0325.html" rel="alternate"/>
    <summary>This is to inform you about the new stable release of Nuitka. It is the extremely compatible Python compiler,
“download now”.</summary>
    <category term="compiler" label="compiler"/>
    <category term="Python" label="Python"/>
    <category term="Nuitka" label="Nuitka"/>
    <published>2012-11-11T16:29:00+00:00</published>
  </entry>
  <entry>
    <id>https://nuitka.net/posts/static-compilation-that-is-the-point.html</id>
    <title>Static Compilation - That is the point</title>
    <updated>2012-12-02T12:23:32+00:00</updated>
    <author>
      <name>Kay Hayen</name>
    </author>
    <content type="html">&lt;section id="static-compilation-that-is-the-point"&gt;

&lt;p&gt;In a recent post, Stefan Behnel questioned the point of static
compilation and suggests that in order to be useful, a static compiler
&lt;strong&gt;needs&lt;/strong&gt; to add something on top.&lt;/p&gt;
&lt;p&gt;This is going to be a rebuttal.&lt;/p&gt;
&lt;section id="compatibility-i-mean-it"&gt;
&lt;h2&gt;Compatibility, I mean it&lt;/h2&gt;
&lt;p&gt;First of all, let me start out, by saying that Nuitka is intended to be
the fully optimizing compiler of Python. The optimizing part is not yet
true. Right now, it’s probably a correct compiler of Python. Correct in
the sense that it’s compatible to CPython as far as possible.&lt;/p&gt;
&lt;p&gt;As examples of what I mean with compatibility:&lt;/p&gt;
&lt;ul class="simple"&gt;
&lt;li&gt;&lt;p&gt;Nuitka will hold references to local variables of frames, when an
exception is raised, and will release them only once the next
exception is raised.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Nuitka will give the same error messages for all kinds of errors. For
example, the parameter parsing of functions will be the same.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Nuitka provides all language constructs no matter how absurd or
unused they are.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/section&gt;
&lt;section id="compatibility-slower"&gt;
&lt;h2&gt;Compatibility != Slower&lt;/h2&gt;
&lt;p&gt;While generally Nuitka will have a hard time to be faster &lt;em&gt;and&lt;/em&gt;
compatible to CPython, I don’t have much concern about that. Using
guards between optimistic, and less optimistic variants of code, there
is no doubt in my head, that for programs, lots of code will only need
very minimal type annotation and still receive respectable speedups.&lt;/p&gt;
&lt;p&gt;Of course, at this point, this is only speculation. But I somehow gather
that the sentiment is that incompatible and fast &lt;em&gt;need&lt;/em&gt; to go along. I
totally dispute that.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="language-extensions"&gt;
&lt;h2&gt;Language Extensions&lt;/h2&gt;
&lt;p&gt;Now, the “in addition” stuff, that Stefan is talking about. I don’t see
the point at all. It is quite obvious that everything you can say with
&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;cdef&lt;/span&gt;&lt;/code&gt; syntax, could also be said with a more Pythonic syntax. And if
it were missing, it could be added. And where it’s a semantic change, it
should be frowned upon.&lt;/p&gt;
&lt;p&gt;For the Nuitka project, I never considered an own parser of Python. No
matter how easy it would be, to roll your own, and I understand that
Cython did that, it’s always going to be wrong and it’s work. Work that
has no point. The CPython implementation exhibits and maintains the
module &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;ast&lt;/span&gt;&lt;/code&gt; that works just fine.&lt;/p&gt;
&lt;p&gt;For Python, if this were so really useful, such language extensions
should be added to Python itself. If there were missing meaningful
things, I contend they would best be added there, not in a fork of it.
Note how &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;ctypes&lt;/span&gt;&lt;/code&gt; and &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;cffi&lt;/span&gt;&lt;/code&gt; &lt;strong&gt;have&lt;/strong&gt; been added. When I created
bindings for Ada code (C exports) to Python, it was so easy to do that
in pure Python with ctypes. I so much enjoyed that.&lt;/p&gt;
&lt;p&gt;So, slow bindings are in my view really easy to create with plain Python
now. Somebody ought to make a “.h” to &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;ctypes&lt;/span&gt;&lt;/code&gt;/&lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;cffi&lt;/span&gt;&lt;/code&gt; declarations
converter, once they are really faster to use (possibly due to Nuitka).
For Nuitka it should be possible to accelerate these into direct calls
and accesses. At which point, mixing generated C code and C include
statements, will just be what it is, a source of bugs that Nuitka won’t
have.&lt;/p&gt;
&lt;div class="admonition note"&gt;
&lt;p class="admonition-title"&gt;注解&lt;/p&gt;
&lt;p&gt;Further down, I will give examples of why I think that &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;cdef&lt;/span&gt;&lt;/code&gt; is
inferior to plain Python, even from a practical point of view.&lt;/p&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section id="lack-of-interpreter-is-bad"&gt;
&lt;h2&gt;Lack of Interpreter is bad&lt;/h2&gt;
&lt;p&gt;Static compilation vs. interpretation as a discussion has little merits
to me. I find it totally obvious that you don’t need static compilation,
but 2 other things:&lt;/p&gt;
&lt;ol class="arabic simple"&gt;
&lt;li&gt;&lt;p&gt;You may need interpretation.&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;And may need speed.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;To me static code analysis and compilation are means to achieve that
speed, but not intended to remove interpretation, e.g. plugins need to
still work, no matter how deep the go.&lt;/p&gt;
&lt;p&gt;For Cython syntax there is no interpreter, is there? That makes it loose
an important point. So it has to have another reason for using it, and
that would be speed and probably convenience. Now suppose Nuitka takes
over with these benefits, what would it be left with? Right. Nothing. At
all. Well, of course legacy users.&lt;/p&gt;
&lt;p&gt;The orinal sin fall of PyRex - that is now Cython - is nothing that
Nuitka should repeat.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="no-lock-in"&gt;
&lt;h2&gt;No Lock-in&lt;/h2&gt;
&lt;p&gt;The Cython language is so underspecified, I doubt anybody could make a
compatible implementation. Should you choose to use it, you will become
locked in. That means, if Cython breaks or won’t work to begin with, you
are stuck.&lt;/p&gt;
&lt;p&gt;That situation I totally despise. It seems an unnecessary risk to take.
Not only, if your program does not work, you can’t just try another
compiler. You also will never really know, if it’s either your fault or
Cython’s fault until you do know, whose fault it is. Find yourself
playing with removing, adding, or re-phrasing &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;cdef&lt;/span&gt;&lt;/code&gt; statements, until
things work.&lt;/p&gt;
&lt;p&gt;Common. I would rather use PyPy or anything else, that can be checked
with CPython. Should I ever encounter a bug with it, I can try CPython,
and narrow down with it. Or I can try Jython, IronPython, or low and
behold, Nuitka.&lt;/p&gt;
&lt;p&gt;I think, this totally makes it obvious, that static compilation of a
non-Python language has no point to people with Python code.&lt;/p&gt;
&lt;p&gt;What I will always admit, is that Cython is (currently) the best way to
create fast bindings, because Nuitka is not ready yet. But from my point
of view, Cython has no point long term if a viable replacement that is
Pythonic exists.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="python-alone-is-a-point"&gt;
&lt;h2&gt;Python alone is a point&lt;/h2&gt;
&lt;p&gt;So, if you leave out static compilation vs. interpretation and JIT
compilation, what would be the difference between PyPy and Nuitka? Well,
obviously PyPy people are a lot cooler and cleverer. Their design is
really inspiring and impressive. My design and whole approach to Nuitka
is totally boring in comparison.&lt;/p&gt;
&lt;p&gt;But from a practical standpoint, is there any difference? What is the
difference between Jython and PyPy? The target VM it is. PyPy’s or
Java’s. And performance it is, of course.&lt;/p&gt;
&lt;p&gt;So, with Python implementations all being similar, and just differing in
targets, and performances, do they all have no point? I believe taken to
the logical conclusion, that is what Stefan suggests. I of course think
that PyPy, Nuitka, and Jython have have as much of a point, as CPython
does.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="type-annotations-done-right"&gt;
&lt;h2&gt;Type Annotations done right&lt;/h2&gt;
&lt;p&gt;And just for fun. This is making up a use cases of type annotations:&lt;/p&gt;
&lt;div class="highlight-python notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;plong&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;long&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;python_version&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="nb"&gt;int&lt;/span&gt;


&lt;span class="nd"&gt;@hints&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;signature&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;plong&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;plong&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;some_function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;**&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;Notice how &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;plong&lt;/span&gt;&lt;/code&gt; depends on an expression, that may become known
during compile time or not. Should that turn out to be not possible,
Nuitka can always generate code for both branches and branch when
called.&lt;/p&gt;
&lt;p&gt;Or more complex and useful like this:&lt;/p&gt;
&lt;div class="highlight-python notranslate"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;guess_signature&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="n"&gt;types&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="kc"&gt;None&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;

    &lt;span class="n"&gt;emit&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;types&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;append&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;arg&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;inspect&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;getargnames&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;arg&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;l&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;emit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;list&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;arg&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;f&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;emit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;float&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;elif&lt;/span&gt; &lt;span class="n"&gt;arg&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;i&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;emit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
            &lt;span class="n"&gt;hints&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;warning&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Unknown type &lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="n"&gt;arg&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="n"&gt;emit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kc"&gt;None&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;hints&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;signature&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;types&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;


&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;many_hints&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="c1"&gt;# Won&amp;#39;t raise exception.&lt;/span&gt;
    &lt;span class="n"&gt;hints&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;doesnot_raise&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="c1"&gt;# Signature to be inferred by conventions&lt;/span&gt;
    &lt;span class="n"&gt;guess_signature&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="c1"&gt;# No side effects&lt;/span&gt;
    &lt;span class="n"&gt;hints&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;pure&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;func&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;


&lt;span class="nd"&gt;@many_hints&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;some_func1&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mf"&gt;2.0&lt;/span&gt;


&lt;span class="nd"&gt;@many_hints&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;some_func2&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;


&lt;span class="nd"&gt;@many_hints&lt;/span&gt;
&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;some_func3&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;l&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;This is just a rough sketch, but hopefully you get the idea. Do this
with Cython, can you?&lt;/p&gt;
&lt;p&gt;The hints can be put into decorators, which may be discovered as
inlinable, which then see more inlines. For this to work best, the loop
over the compile time constant code object, needs to be unrolled, but
that appears quite possible.&lt;/p&gt;
&lt;p&gt;The signatures can therefore be done fully automatic. One could use
prefix notation to indicate types.&lt;/p&gt;
&lt;p&gt;Another way would put fixed types for certain variable names. In Nuitka
code, “node”, “code”, “context”, etc. have always the same types. I
suspect many programs are the same, and it would be sweet, if you could
plug something in and check such types throughout all of the package.&lt;/p&gt;
&lt;p&gt;And then, what do you do then? Well, you can inspect these hints at run
time as well, they work with CPython as well (though they won’t make
things faster, only will that find errors in your program), they will
even work with PyPy, or at least not harm it. It will nicely JIT them
away I suppose.&lt;/p&gt;
&lt;p&gt;Your IDE will like the code. syntax highlighting, auto indent will work.
With every Python IDE. PyLint will find the bugs I made in that code up
there. And Nuitka will compile it and benefit from the hints.&lt;/p&gt;
&lt;p&gt;My point here really is, that &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;cdef&lt;/span&gt;&lt;/code&gt; is not flexible, not standard,
not portable. It should die. It totally is anti-Pythonic to me.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="elsewhere"&gt;
&lt;h2&gt;Elsewhere&lt;/h2&gt;
&lt;p&gt;In Java land, people compile to machine code as well. They probably also
- like stupid me - didn’t understand that static compilation would have
no point. Why do they do it? Why am I using compiled binaries done with
their compiler then?&lt;/p&gt;
&lt;p&gt;And why didn’t they take the chance to introduce ubercool &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;cdef&lt;/span&gt;&lt;/code&gt;
a-likes while doing it? They probably just didn’t know better, did they?&lt;/p&gt;
&lt;p&gt;No seriously. A compiler is just a compiler. It takes a source code in a
language and turns it into a package to execute. That may be a required
or an optional step. I prefer optional for development turn around. It
should try and make code execute as fast as it can. But it should not
change the language. With Cython I have to compile. With Nuitka I could.&lt;/p&gt;
&lt;p&gt;In fact, I would be hard pressed to find another example of a compiler
that extends the interpreted language compiled, just so there is a point
in having it.&lt;/p&gt;
&lt;/section&gt;
&lt;section id="conclusion"&gt;
&lt;h2&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;Nuitka has a point. On top of that I enjoy doing it. It’s great to have
the time to do this thing in the correct way.&lt;/p&gt;
&lt;p&gt;So far, things worked out pretty well. My earlier experimentations with
type inference had shown some promise. The “value friends” thing, and
the whole plan, appears relatively sound, but likely is in need of an
update. I will work on it in december. Up to now, and even right now I
worked on re-formulations, that should have made it possible to get more
release ready effects from this.&lt;/p&gt;
&lt;p&gt;When I say correct way, I mean this. When I noticed that type inference
was harder than it should be, I could take the time and re-architecture
things so that it will be simpler. To me that is fun. This being my
spare time allows me to do things this efficiently. That’s not an
excuse, it’s a fact that explains my approach. It doesn’t mean it makes
less sense, not at all.&lt;/p&gt;
&lt;p&gt;As for language compatibility, there is more progress with Python3. I am
currently changing the &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;class&lt;/span&gt;&lt;/code&gt; re-formulations for Python2 and Python3
(they need totally different ones due to &lt;code class="docutils literal notranslate"&gt;&lt;span class="pre"&gt;metaclass&lt;/span&gt;&lt;/code&gt; changes) and then
“test_desc.py” should pass with it too, which will be a huge achievement
in that domain. I will do a post on that later.&lt;/p&gt;
&lt;p&gt;Then infrastructure, should complete the valgrind based benchmark
automatism. Numbers will become more important from now on. It starts to
make sense to observe them. This is not entirely as fun. But with
improving numbers, it will be good to show off.&lt;/p&gt;
&lt;p&gt;And of course, I am going to document some more. The testing strategy of
Nuitka is worth a look, because it’s totally different from everything
else people normally do.&lt;/p&gt;
&lt;p&gt;Anyway. I am not a big fan of controversy. I respect Cython for all it
achieved. I do want to go where it fails to achieve. I should not have
to justify that, it’s actually quite obvious, isn’t it?&lt;/p&gt;
&lt;div class="line-block"&gt;
&lt;div class="line"&gt;Yours,&lt;/div&gt;
&lt;div class="line"&gt;Kay&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;/section&gt;
</content>
    <link href="https://nuitka.net/posts/static-compilation-that-is-the-point.html" rel="alternate"/>
    <summary>In a recent post, Stefan Behnel questioned the point of static
compilation and suggests that in order to be useful, a static compiler
needs to add something on top.</summary>
    <category term="Python" label="Python"/>
    <category term="Nuitka" label="Nuitka"/>
    <category term="compiler" label="compiler"/>
    <published>2012-12-02T12:23:32+00:00</published>
  </entry>
</feed>
